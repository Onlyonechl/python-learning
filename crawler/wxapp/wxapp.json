{"title": "微信小程序开发，如何优雅地兼容 ", "author": "Rolan", "pub_time": "2018-9-19 00:02", "article_content": "关于单个 API 如何兼容，微信官方提供了兼容文档，因此我们这里不再赘述。下面主要讨论在整个项目如何优雅地处理兼容问题。问题如果在每处需要兼容的地方都写上一堆兼容相关的代码，随着代码量增加，会出现以下问题：代码难以阅读兼容方案有变动时，需要改动多处随着时间推移，你的代码才是最需要并且是最难兼容的思考最理想的情况是不需要任何兼容处理，因此可以反推出兼容性处理的代码并不是代码正常流程中的一部分，基于此：兼容的细节不必暴露兼容的方案应该统一兼容的方案可方便地变动解决方案1.将兼容方案隐藏，对外提供接口即可比如 wx.showLoading 是在 1.1.0 版本之后才提供的，对于之前的版本需要兼容。我们选择将其放在 show-loading.js 中，内部进行兼容性相关处理，并对外提供 showLoading 方法。这样调用者只需调用 showLoading 方法即可，不用考虑兼容性的问题，而且如果兼容的方式有变动，只需改动 show-loading.js 一处即可。2.兼容的处理还有共性可以抽象兼容处理多了之后我们会发现，对兼容所做的处理无非两方面：支持该方法时，直接使用对应方法不支持该方法时，做一些兼容处理因此这种模式我们又可以抽离出来，这样做当然有一些好处：减少重复代码做一些共性的处理时，我们又只用改动一处（比如当不兼容官方 API 时加上对应统计，用于分析当前应用跨版本的情况）比如我们抽离出这样一个简单的 compatible.js 用于处理兼容时的共性问题：之前的 showLoading.js 我们可以这样写：简单吧 :)，这种写法的意思是兼容时正常展示 loading 即可，不兼容时则不展示。当然可能有完美主义者会觉得『怎么能不展示呢？我就是要展示！』 那么我们可以这样写：用 wx.showToast 伪造了一个 showLoading。3.文件组织兼容性的文件可能会越来越多，对于我这种有收拾的人，看到所有东西散乱地扔在一个抽屉里肯定是不能忍的...因此我们可以多用几个小盒子把它们分门别类地装起来。小盒子怎么选呢？其实官方已经给出了答案，官方 API 是按照不同的功用分组的，因此我们拿分组当『盒子』即可。最终的文件组织像这样："}
{"title": "微信小程序授权登陆方案以及在Taro下利用Decorator修饰器实现 ", "author": "Rolan", "pub_time": "2018-9-13 00:34", "article_content": "选用Taro做技术框架的原因：最近公司需要开发一款新的小程序，主要是做付费知识相关的产品，涉及到了虚拟商品支付，对于IOS的对于虚拟商品支付的种种限制，加上类似小程序的相关调研，决定IOS支付的方式走h5公总号支付绕开限制，所以在框架选型上面需要一套代码加一点兼容代码，就可以生成小程序和H5版本的库，考虑到本身技术栈以react为主，所以最后老大选择了Taro进行开发对于Taro的简单介绍以及提供能力可以浏览 Taro初探需求场景在微信小程序里面，需要做助力、拼团等逻辑的时候，有些需要鉴权的接口等，要再用户授权登录完毕之后，在请求的 header 带上用户的 accessToken ，所以要确保这些接口在用户登录完成之后再开始进行请求之所以要用户授权登录而不用小程序的静态登录方式，是因为在兼容H5的时候，登陆流程是通过公众号登录的，在不想产生多余的数据下，使用用户的 union_id 作为唯一依据，用 wx.login这种形式拿用户的 code 登录只能拿到 open_id ，与我们的需求不符合UnionID机制说明 · 小程序我们这边与后端约定是先通过用户授权 wx.getUserInfo ，拿到用户信息发送给后端进行注册或者登陆，后端返回一个 accessToken 作为用户的凭证，调用其他接口的时候在 header 带着这个 accessToken ，后端就能在需要的时候根据 accessToken 获取到当前用户信息小程序的登录流程如下由于小程序的生命周期机制，生命周期是异步执行的，生命周期之间是无法阻塞执行，如果在 onLaunch 的时候进行用户登录的逻辑，在弱网的情况下，会出现一种情况就是用户登录没完成的情况下，还没拿到 accessToken 就开始了page里面的请求接口，这样会导致接口报错解决思路利用修饰器 Decorator 、React的高阶组件 HOC 以及 async/await ，劫持当前页面调用接口的声明周期，等待封装好的用户登录逻辑执行完以后，再进行当前声明周期里面其他调用的执行。举个例子在分享助力的场景下，新用户点击分享用户的卡片进来小程序，需要弹出一个授权弹框等用户授权登陆成功以后，才能进行助力接口的调用。要注意的是，劫持的是当前声明周期的方法，并不会阻塞到其他生命周期，例如劫持 willMount 的时候， didShow 、 didMount 等周期依然会照样按顺序执行，并不会等待 willMount 结束后再进行代码分享主要分享修饰器的使用以及作用，登陆逻辑主要参考流程图即可，代码暂不做分享写一个能劫持传入组件生命周期的修饰器由于Taro暂时不支持无状态组件，所以只能使用HOC的反向劫持能力，继承传入的组件，这个时候就可以通过等待登录逻辑完成，再执行劫持的生命周期withLogin.jsconst LIFE_CYCLE_MAP = ['willMount', 'didMount', 'didShow'];\r\n\r\n/**\r\n *\r\n * 登录鉴权\r\n *\r\n * @param {string} [lifecycle] 需要等待的鉴权完再执行的生命周期 willMount didMount didShow\r\n * @returns 包装后的Component\r\n *\r\n */\r\nfunction withLogin(lifecycle = 'willMount') {\r\n  // 异常规避提醒\r\n  if (LIFE_CYCLE_MAP.indexOf(lifecycle) < 0) {\r\n    console.warn(\r\n      `传入的生命周期不存在, 鉴权判断异常 ===========> $_{lifecycle}`\r\n    );\r\n    return Component => Component;\r\n  }\r\n    \r\n  return function withLoginComponent(Component) {\r\n    // 避免H5兼容异常\r\n    if (tool.isH5()) {\r\n      return Component;\r\n    }\r\n      \r\n    // 这里还可以通过redux来获取本地用户信息，在用户一次登录之后，其他需要鉴权的页面可以用判断跳过流程\r\n    // @connect(({ user }) => ({\r\n    //   userInfo: user.userInfo,\r\n    // }))\r\n    class WithLogin extends Component {\r\n      constructor(props) {\r\n        super(props);\r\n      }\r\n\r\n      async componentWillMount() {\r\n        if (super.componentWillMount) {\r\n          if (lifecycle === LIFE_CYCLE_MAP[0]) {\r\n            const res = await this.$_autoLogin();\r\n            if (!res) return;\r\n          }\r\n\r\n          super.componentWillMount();\r\n        }\r\n      }\r\n\r\n      async componentDidMount() {\r\n        if (super.componentDidMount) {\r\n          if (lifecycle === LIFE_CYCLE_MAP[1]) {\r\n            const res = await this.$_autoLogin();\r\n            if (!res) return;\r\n          }\r\n\r\n          super.componentDidMount();\r\n        }\r\n      }\r\n\r\n      async componentDidShow() {\r\n        if (super.componentDidShow) {\r\n          if (lifecycle === LIFE_CYCLE_MAP[2]) {\r\n            const res = await this.$_autoLogin();\r\n            if (!res) return;\r\n          }\r\n\r\n          super.componentDidShow();\r\n        }\r\n      }\r\n    }\r\n      \r\n    $_autoLogin = () => {\r\n      // ...这里是登录逻辑\r\n    }\r\n  }\r\n}\r\n\r\nexport default withLogin;\r\n复制代码注意使用的组件内必须有对应定义的生命周期，而且 不能使用箭头函数式 ，例如 componentWillMount(){} 不能写成 componentWillMount = () => {} ，会劫持失败需要登录鉴权页面的使用方式pages/xxx/xxx.jsimport Taro, { Component } from '@tarojs/taro';\r\nimport { View } from '@tarojs/components';\r\nimport withLogin from './withLogin'\r\n\r\n@withLogin()\r\nclass Index extends Component {\r\n  componentWillMount(){\r\n    console.log('Index willMount')\r\n    // 需要带accessToken调用的接口等 \r\n  }\r\n    \r\n  componentDidMount(){\r\n    console.log('Index didMount')  \r\n  }\r\n\r\n  render() {\r\n    console.log('Index render');\r\n\r\n    return <View />;\r\n  }\r\n}\r\n\r\nexport default Index;\r\n复制代码注意如果在继承的时候使用了redux去connect了数据，使用之后已自动为组件的props附带上connect的数据，被修饰的组件不需要再connect去拿这一个数据, 不然可能会出现报错 Setting data field \"xxx\" to undefined is invalid .利用修饰器这个特性，我们还可以对小程序做一层浏览打点，分享封装等操作"}
{"title": "小程序-云开发 ", "author": "Rolan", "pub_time": "2018-9-13 00:16", "article_content": "最新更新的微信 web 开发者工具支持了云开发和之前免费提供的自动部署的测试环境不同，这次是生产和开发都不需要一台独立的服务器了取而代之的是云文件，云函数和云数据库（和 Bmob 云有点像）更新到最新的微信 web 开发者工具就行了https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html开通新建项目，使用云开发快速启动项目模板（必须是自己的 APPID，测试 APPID 没有这个模板）云文件其实就是一个在小程序中使用比较方便的对象存储APIwx.cloud.uploadFile // 如果上传至同一路径则是覆盖写\r\nwx.cloud.downloadFile\r\nwx.cloud.deleteFile\r\nwx.cloud.deleteFile图片上传 Demowx.chooseImage({\r\n    success: function(res) {\r\n        // 获取文件路径\r\n        const filePath = res.tempFilePaths[0]\r\n        // 定义上传位置，不要以/开头\r\n        const cloudPath = 'upload/test.png'\r\n        wx.cloud.uploadFile({\r\n            filePath: filePath,\r\n            cloudPath: cloudPath,\r\n            success: res => {\r\n                console.log('[上传文件] 成功：', res)\r\n            },\r\n            fail: e => {\r\n                console.error('[上传文件] 失败：', e)\r\n            },\r\n            complete: () => {\r\n                console.log('结束调用')\r\n            }\r\n        })\r\n    }\r\n})云函数云函数在本地编写，上传到云端的 Node.js 运行环境中执行，然后返回结果。可以通过云函数后端 SDK 搭配使用多种服务，比如数据库和存储 API(wx-server-sdk)。定义云函数存放目录云函数根目录下的第一级目录（云函数目录）是与云函数名字相同的，如果函数已经上传到云端运行环境，则会有一个特殊的云图标云函数代码调用代码wx.cloud.callFunction({\r\n    name: 'sum',\r\n    data: {\r\n        a: 1,\r\n        b: 2\r\n    },\r\n    success: res => {\r\n        console.error('[云函数] [sum] 调用成功：', res)\r\n        console.log(JSON.stringify(res.result))\r\n    },\r\n    fail: err => {\r\n        console.error('[云函数] [sum] 调用失败：', err)\r\n    }\r\n})输出结果存放在 res.result 中，为了看出 event 和 context 的作用，在返回结果中顺便返回了这两个内容,打印了出来可以看到，event 就是传入的参数，同时会自动添加 userInfo 信息。context 是云函数的运行环境参数{\r\n    event: {\r\n        a: 1,\r\n        b: 2,\r\n        userInfo: {\r\n            appId: 'xxxxx',\r\n            openId: 'xxxxxx'\r\n        }\r\n    },\r\n    context: {\r\n        callbackWaitsForEmptyEventLoop: false,\r\n        memory_limit_in_mb: 256,\r\n        time_limit_in_ms: 20000,\r\n        request_id: '422e93b4-b5db-11e8-b8a8-525400e8849e',\r\n        environ: 'xxxx'\r\n    },\r\n    sum: 3\r\n}数据库官方介绍说是云开发提供了一个 JSON 数据库，使用起来也很简单先创建一个集合，也就是数据库的table吧但是并不要求是每一行的数据结构都一样待续...."}
{"title": "微信小程序 | 切换按钮或者view的选中状态 ", "author": "Rolan", "pub_time": "2018-9-13 00:45", "article_content": "实现非常简单，通过一个简单的判断当前data中的选中值，点击按钮时更新data值，重新渲染页面。index.wxml文件<view class=\"switch-type\">\r\n    <view class=\"btn {{currentSelectTripType == 'pinche' ? 'active' : ''}}\" bindtap='selectedPinche' data-id='pinche'>拼车</view>\r\n    <view class=\"btn {{currentSelectTripType == 'baoche' ? 'active' : ''}}\" bindtap='selectedBaoche' data-id='baoche'>包车</view>\r\n  </view>index.js文件Page({\r\n  data: {~~~~\r\n    currentSelectTripType: 'pinche',\r\n  },\r\n  // 更新data 切换选中状态\r\n  selectedPinche: function (e) {\r\n    this.setData({\r\n      currentSelectTripType: e.currentTarget.dataset.id\r\n    })\r\n  },\r\n  selectedBaoche: function(e) {\r\n    this.setData({\r\n      currentSelectTripType: e.currentTarget.dataset.id\r\n    })\r\n  },\r\n})附上一个简单的样式index.wxss.switch-type {\r\n  display: flex;\r\n}\r\n.switch-type .btn:first-child {\r\n  border-top-right-radius: 0;\r\n  border-bottom-right-radius: 0;\r\n}\r\n.switch-type .btn:last-child {\r\n  border-top-left-radius: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n.switch-type .btn {\r\n  background: #dfdfdf;\r\n  padding: 10rpx 40rpx;\r\n}\r\n.switch-type .btn.active {\r\n  border: 2rpx solid #007bff;\r\n  background: #fff;\r\n}"}
{"title": "美团扫码付小程序的优化实践 ", "author": "Rolan", "pub_time": "2018-9-14 00:12", "article_content": "短短几年的时间，微信小程序已经从一颗小小的萌芽成长为参天大树，形成了较大规模的开发者生态系统，尤其是在支付、线下垂直领域潜力巨大。作为领先的生活服务平台，美团的技术团队在小程序领域也进行了很多的探索和实践。像mpvue就是一款使用Vue.js开发微信小程序的前端框架，而且已经在美团点评多个实际业务项目中得到了验证，详细介绍大家可以阅读《 用Vue.js开发微信小程序：开源框架mpvue解析 》一文。目前，mpvue已经开源，项目地址是： https://github.com/Meituan-Dianping/mpvue。本文将介绍扫码付小程序的实践，根据美团前端工程师陈瑶在美团第31期技术沙龙（点击可以查看这次沙龙四场演讲的Slides和视频）的演讲《金融扫码付H5迁移小程序拓荒之旅》整理而成。什么是扫码付小程序？美团扫码付是一款面向C端消费者推出的线下收单业务，相信大家已经在线下很多餐馆和其他生活服务商家体验过了。这项业务主要就是通过小程序提供服务的，而在实际场景中，用户先使用微信“扫一扫”功能，扫描商家二维码，系统会自动调用扫码付小程序，进入支付页面，最后输入金额完成商品的支付。目标及数据分析支付服务最核心的指标，显然就是用户支付成功的占比，我们称之为支付转化率。对扫码付业务而言，支付转化率的百分比越高，扫码付业务的营业额也就越高，其带来的收益是正相关的。因此提升扫码付小程序的支付转化率，就成为我们技术团队的重要工作。经过数据分析，我们发现转化率流失主要存在于以下两个环节：扫码到进入小程序环节（外部环节）进入小程序到支付环节（内部环节）从扫码到进入小程序环节，微信会完成小程序基本信息获取、资源准备（代码下载或更新）等准备事项。在准备事项中，如果准备失败或等待时间过长，就会导致用户离开，这部分由微信控制的环节，我们称之为外部环节。在进入小程序到支付环节，页面会进行渲染、数据请求等，如果渲染时间长、数据请求时间长也容易导致用户离开，同样，如果数据请求失败也会造成用户使用过程的终止，这部分由我们美团扫码付技术团队控制的环节，称之为内部环节。如何提升外部环节转化率？对于小程序开发者而言，扫码到小程序调起这个环节是黑盒的，我们无法得知其中的细节。而我们在扫码付小程序中尝试和微信的同学做了一次梳理，发现扫码付小程序在外部环节的丢失率较高，查询数据后，我们发现其中大部分用户手动点击了右上角的退出。从业务视角出发，用户使用扫码付小程序，可认为他们有强需求进行支付，而造成用户手动点击退出的部分原因可能是等待时间过长。而在这个环节对时间造成影响更多的是资源准备，即小程序代码下载或者更新的行为。根据经验，影响下载和更新时间可能的因素包括两个方面：一个是网络，另一个是代码包。因为用户的网络是我们无法控制的，只能尝试从代码包开始下手。而在当时未使用分包的情况下，我们的主包大小约为3M，这意味着新用户和无缓存小程序用户均需要在首次使用时等待下载3M左右的包。在这种情况下，虽然用户享受了小程序离线缓存包的福利，却丢失了大部分新用户的体验。于是我们尝试从包代码层面做一些优化：增加分包加载机制。用户在使用扫码付业务时会按需进行加载，优化小程序首次启动的下载时间。减小主包和分包大小。按照空主包的概念进行优化。在进行分包加载机制后，主包因为无法最小化而影响首次下载时间。一方面，原有的3M整包中，图片大小占用了50%大小，我们将所有的内含二进制和Base64图片分发到了CDN；另一方面，部分可移出的业务分发到了其他分包。在做了这些事情后，扫码付分包从原先的整包3M缩减到了361K（主包300K+分包61K），而外部环节的转化率也提升了3%。虽然转化率提升了，但前置环节的转化率仍然有部分丢失，理论上继续缩减300K的主包能有效提升，但由于业务性质的原因无法再继续缩减，于是我们向微信小程序提出了独立分包的概念：用户在使用独立分包时无需下载主包。通过独立分包加载，程序使用期间下载更新阶段，只需要加载61K的分包大小。目前这个功能还在灰度阶段，扫码付小程序团队也在作为第一批的内测用户进行体验，优化效果在之后的实践中，我们也会分享出来，大家可关注美团技术团队公众号，持续关注我们。如何提升内部环节转化率？在进入小程序到支付这个环节，属于我们的业务流程。在这个环节中的转化率丢失虽然我们能够掌控，但是必须有所依据，才能对症下药。所以我们做了一些数据监控：业务核心流程监控。业务核心流程指用户进入小程序后所涉及的影响最终支付的中间流程，中间流程的丢失会直接影响业务整个转化率丢失，所以这里必须进行监控。而业务核心流程监控需要可监控的具体指标，我们对进入小程序和支付进行了关键动作拆解，从开始扫码到用户看到页面，再到点击支付、初始化订单、支付成功。拆解完这些关键动作，再针对每一步可控环节，进行技术指标的拆解。从入口到出口的每一步制定关键指标（扫码加载转化率、点击意愿等，见下图），形成一个至上而下的漏斗，产出多个可量化指标，来做业务流程的监控。对于这部分可量化指标，可以通过长期的观察分析来提升转化率。异常监控。页面的任何异常都可能导致支付页面的渲染失败，从而无法正常支付。我们对页面的接口异常、微信API异常进行了监控。接口异常可在API（wx.request）的fail函数中直接捕获，从而上报监控；对于接口超时，则只能通过全局的app.json进行全局设置（默认60s，时间过长，对用户体验较差），此前我们曾尝试在小程序中设置全局的5s请求超时，但实际应用中并非所有场景需要设置统一的超时，最终我们单独封装了接口请求超时。微信API的异常通过微信的一些fail中进行监控即可。性能监控。小程序内部转化环节中关注进入小程序后的白屏时间和可交互时间。内部白屏时间从onLoad处打点，到页面onReady处结束；内部可交互时间从onLoad处打点，到页面数据请求结束后的可点击支付时间截止。日常监控中，我们也发现了一些问题，例如接口调用超时、接口调用失败，这些问题会导致页面流程终止。针对这些问题我们做了一些优化：接口合并。支付页面的外网链路接口请求数量较多，任意一个接口的失败都会导致问题，合并接口则可以减少问题出现概率，提升中间流程的转化率。增加重试机制。在出现接口异常的情况下，会直接导致页面阻塞，如果通过重试能成功，则可以提升转化率。整个流程中可重试的有两类：自有的接口请求异常，小程序API调用异常。对于这两类异常，在接口超时、调用失败时采取重试。而为了避免在极端情况下服务端流量陡增、峰值倍数增加，页面的可重试次数会在前置获取全局配置时根据“可重试次数”进行控制，并且每次重试需要在一段时间后用户手动触发。超过重试次数时，则流程终止。如何监控内部和外部环节？前面我们也提到，对于小程序开发者而言，扫码到小程序调起这个环节是黑盒的，我们开发者无法得知此处的细节，所以说在监控外部环节这方面我们开发者似乎可做的事情屈指可数。但是，不知道细心的同学有没有发现，微信在每次扫码后会给我们在query参数上附带一个scancode_time字段。其实这个字段表示的是用户在使用扫一扫时微信服务端记录的时间，所以基于这个字段的考量，我们做了如下尝试，针对以下两个参数值分别做了实时监控：支付页面的白屏时间（用户看到首屏的客户端时间—用户微信扫一扫服务端时间+服务端客户端差额时间）。支付页面的用户可交互时间（页面Loading完毕时间—用户微信扫一扫服务端时间+服务端客户端差额时间）。由于客户端的时间戳是获取本地手机系统的时间，可能存在差异。所以为了保证上报的准确性，我们在每次onLoad的时候取了一次我们服务端的时间，记录了客户端的时间与服务端的一个时间差额，并且在后续所有涉及到服务端的时间都参照这个时间差额做计算（网络100-200ms级别的传输时延，暂可忽略）。但由于我们扫码付小程序的特殊应用场景就是为了保障用户进行快速可靠的支付，既然在外部环节可控度不高，那是不是可以考虑在内部的业务流程方面把监控统计做的细粒度一点，做到能对每一个可能影响到支付的环节有数据可循呢？我们针对这个方向，区别于传统的PV、UV统计，并对业务上报做了如下分类：根据上报的场景划分：实时性监控部分与统计部分。根据上报的类型划分：Error类型、Event类型（普通生命周期事件）、Metric类型（自定义Event类型，维度可自定义）、自定义测速类型（延时趋势与分布）。基于上述方案的探索，我们团队基本上做到了对可能影响支付环节的很多业务指标，进行了整体的把控。从而在下一步，针对每个潜在的可优化点做进一步思考与考量，然后作出及时的策略优化与更新。通过对扫码付小程序的探索，我们积累了很多优化经验。美团的价值观是追求卓越，对于能优化的方面，我们还会进一步去探索，也欢迎更多的同学跟我们一起讨论。作者简介陈瑶，2015年校招入职美团，此前参与过美团平台移动端触屏版的前端开发工作，从0到1参与了智能支付应用层的前端建设工作，现负责美团收单业务扫码付小程序业务。招聘如果对我们“智能支付大前端团队”感兴趣，可直接简历发送给（chenxuan03@meituan.com）。欢迎加入美团，跟我们一起探索未来。发现文章有错误、对内容有疑问，都可以关注美团技术团队微信公众号（meituantech），在后台给我们留言。我们每周会挑选出一位热心小伙伴，送上一份精美的小礼品。快来扫码关注我们吧！"}
{"title": "微信小程序 短信验证码登录 倒计时 setInterval ", "author": "Rolan", "pub_time": "2018-9-14 00:19", "article_content": "需求：输入手机号 -> 点击获取验证码 -> 进入60s倒计时 短信验证码登录  data: {     seconds: 0, // 读秒    timer: '' // 计时器  },       let that = this      // 开始倒计时      that.setData({         seconds: 60,        timer: setInterval(function(){          let seconds = that.data.seconds          that.setData({ seconds: seconds - 1 })          if (that.data.seconds == 0) {            // 读秒结束 清空计时器            clearInterval(that.data.timer)          }        }, 1000)      })"}
{"title": "微信小程序云开发初体验 ", "author": "Rolan", "pub_time": "2018-9-14 00:22", "article_content": "9.10号微信重磅推出小程序云开发功能，该功能方便了很多逻辑上的问题，至于安全嘛，腾讯的，如果腾讯不看你的，没人看得到，话不多说，跟着腾讯文档进行第一个demo 首先要升级一个开发者工具版本，更新到最新，下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html1、下载到最新的工具之后打开，先创建一个存储我们自己云函数的文件夹命名：functions2、找到project.config.json文件，添加 \"cloudfunctionRoot\": \"functions/\" 配置我们的云函数目录{    \"description\": \"项目配置文件。\",    \"cloudfunctionRoot\": \"functions/\",    \"setting\": {        \"urlCheck\": true,        \"es6\": true,        \"postcss\": true,        \"minified\": true,        \"newFeature\": true    },    \"compileType\": \"miniprogram\",    \"libVersion\": \"2.1.3\",    \"appid\": \"asdaaaaaa\",    \"projectname\": \"\",    \"condition\": {        \"search\": {            \"current\": -1,            \"list\": []        },        \"conversation\": {            \"current\": -1,            \"list\": []        },        \"plugin\": {            \"current\": -1,            \"list\": []        },        \"game\": {            \"current\": -1,            \"list\": []        },        \"miniprogram\": {            \"current\": -1,            \"list\": []        }    }}3、发现云函数的目录是不是别具一格，是的话就右键选择：新建node.js云函数，这时候系统会配置一个基础版的云函数给我们，我们就拿这个基础的云函数走一个流程// 云函数入口文件const cloud = require('wx-server-sdk')cloud.init() //初始化，小程序调用函数前必须要要先调用初始化// 云函数入口函数exports.main = async (event, context) => {  return {    sum: event.a + event.b,//event里面放的都是一些用户传递过来的数据，参数a和参数b    userInfo: event.userInfo //还可以直接获取到用户的openid，这些是腾讯给出来的，并不需要用户去授权，很安全。  }}4、在我们的functions目录中，右键我们的add，选择：上传并部署，然后就开始调用： wx.cloud.callFunction({    name: 'add',    data: {      a: 1,      b: 9    }  }).then((res)=>{    console.log(res)  })5、是不是很激动，如果按照官方给出的文档，可能会遇到下面几个问题：问题①：Cannot read property 'callFunction' of undefined; 遇到该问题很好解决，这个问题一般都是调试基础库版本太低的原因，可以往上调一下。 问题②：发现版本库调高了之后发现了另外一个问题，errCode: -1  | errMsg: Cloud API isn't enabled, please call wx.cloud.init first请先调用 wx.cloud.init() 完成初始化后再调用其他云 API。init 方法可传入一个对象用于设置默认配置，详见文档。;at pages/test/test page getData functionError: errCode: -1  | errMsg: Cloud API isn't enabled, please call wx.cloud.init first请先调用 wx.cloud.init() 完成初始化后再调用其他云 API。init 方法可传入一个对象用于设置默认配置，详见文档。这个问题，就是调用云函数之前需要先进行初始化。wx.cloud.init()就可以了。再去调用云函数。成功获取返回来的数据。官方提供的一个最初的简单小demo就算走通了，剩下的基本上都是此类操作，只是需要对照官方数据库操作进行特别的操作。"}
{"title": "微信小程序语音识别、合成 ", "author": "Rolan", "pub_time": "2018-9-7 00:31", "article_content": "网上前篇一律的微信小程序语音识别博客，在小程序api更新之后让莘莘学子看的一头雾水，这里只叙述前端的工作内容，毕竟朕也只是初出茅庐。先送上预览图：先叙述下原理：利用微信小程序api，录音结束后返回mp3文件；使用方法请看：https://developers.weixin.qq.com/miniprogram/dev/api/getRecorderManager.html录音转换成文件的格式只有两种：acc mp3，所以网上老api返回的是silk格式的都是过时的。切记：微信开发者工具拿到的MP3连接是不可用的，只有在真机上调试返回的是本地文件的路径，这个路径指向录音的mp3文件，是可以用的。如此轻松的拿到mp3文件了，很简单吧~接下来我们将利用百度语音识别合成api：http://ai.baidu.com/docs#/ASR-API/top也许看的一头雾水，没事~百度语音要求：这里配置微信小程序录音api配置后start的值为：{\r\n    numberOfChannels: 1,\r\n    sampleRate:16000,\r\n    format: 'mp3',\r\n    frameSize: 50\r\n  }这样录音后取到的mp3文件是百度语音想要的。方式一 ：是不是要问了百度语音识别不支持mp3格式啊，这就是java后台的事了，网上java mp3转pcm格式的博客数不胜数，让你的java后台去看百度语音api获取token顺便将转换后的pcm格式给转换成文字传给前台吧。是不是百度一大堆的配置和前端没有关系了~松了一口气~好强的前端当然可以拿到后台传输过来的pcm文件地址再去调百度api。选择方式一跳过方式二，直接看再续。方式二 ：如果前端要去做的话，请看api详解：地址：http://ai.baidu.com/docs#/ASR-API/top再续： 这样录音后的mp3文件就被转换成了文字。如果想要语音播放的功能，请继续往下看~很简单微信小程序api：wx.createInnerAudioContext()，地址：https://developers.weixin.qq.com/miniprogram/dev/api/createInnerAudioContext.html看参数;这里要的是src即是MP3的链接啊，我只拿到后台穿过来的文字啊。对，百度语音合成API，不去百度官网看了，太简单了，奉上：　　https://tsn.baidu.com/text2audio?tok=xxxx&cuid=867905025778863&ctp=1&spd=6&lan=zh&tex=xxxx;\r\n　　tok：百度语音token，　　（获取请看额外篇）\r\n　　text:你想要播报的文字。\r\n　　这是一个完整的mp3链接，调用微信小程序api可直接播放。\r\n\r\n\r\n　　额外：百度token的获取；\r\n　　/*百度语音合成获取token*/\r\n  export let getBaiDuToken=()=>{\r\n    return new Promise((resolve)=>{\r\n      wx.request({\r\n        url:  'https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&client_id=xxxxxxxx&client_secret=xxxxxxxxxx',\r\n        method:'GET',\r\n        success: function(r){\r\n          resolve(r);\r\n        },\r\n        fail(res){\r\n          wx.showToast({\r\n            title:\"百度语音合成获取token接口错误\",\r\n            icon:'none'\r\n          });\r\n        }\r\n      })\r\n    });\r\n  };这里的client_id和client_secret是注册百度语音识别平台在控制台中创建应用获取的。"}
{"title": "实现小程序canvas拖拽功能 ", "author": "Rolan", "pub_time": "2018-9-7 00:38", "article_content": "组件地址\r\ngithub.com/jasondu/wx-…\r\n实现效果\r\n如何实现\r\n\r\n使用canvas\r\n使用movable-view标签\r\n\r\n由于movable-view无法实现旋转，所以选择使用canvas\r\n需要解决的问题\r\n\r\n如何将多个元素渲染到canvas上\r\n如何知道手指在元素上、如果多个元素重叠如何知道哪个元素在最上层\r\n如何实现拖拽元素\r\n如何缩放、旋转、删除元素\r\n\r\n看起来挺简单的嘛，就把上面这几个问题解决了，就可以实现功能了；接下来我们一一解决。\r\n如何将多个元素渲染到canvas上\r\n定义一个DragGraph类，传入元素的各种属性（坐标、尺寸…）实例化后推入一个渲染数组里，然后再循环这个数组调用实例中的渲染方法，这样就可以把多个元素渲染到canvas上了。\r\n如何知道手指在元素上、如果多个元素重叠如何知道哪个元素在最上层\r\n在DragGraph类中定义了判断点击位置的方法，我们在canvas上绑定touchstart事件，将手指的坐标传入上面的方法，我们就可以知道手指是点击到元素本身，还是删除图标或者变换大小的图标上了，这个方法具体怎么判断后面会讲解。\r\n通过循环渲染数组判断是非点击到哪个元素到，如果点击中了多个元素，也就是多个元素重叠，那第一个元素就是最上层的元素啦。\r\n###如何实现拖拽元素\r\n通过上面我们可以判断手指是否在元素上，当touchstart事件触发时我们记录当前的手指坐标，当touchmove事件触发时，我们也知道这时的坐标，两个坐标取差值，就可以得出元素位移的距离啦，修改这个元素实例的x和y，再重新循环渲染渲染数组就可以实现拖拽的功能。\r\n如何缩放、旋转、删除元素\r\n这一步相对比较难一点，我会通过示意图跟大家讲解。\r\n我们先讲缩放和旋转\r\n\r\n通过touchstart和touchmove我们可以获得旋转前的旋转后的坐标，图中的线A为元素的中点和旋转前点的连线；线B为元素中点和旋转后点的连线；我们只需要求A和B两条线的夹角就可以知道元素旋转的角度。缩放尺寸为A和B两条线长度之差。\r\n计算旋转角度的代码如下：\r\nconst centerX = (this.x + this.w) / 2;  // 中点坐标\r\nconst centerY = (this.y + this.h) / 2;  // 中点坐标\r\n\r\nconst diffXBefore = px - centerX;   // 旋转前坐标\r\nconst diffYBefore = py - centerY;   // 旋转前坐标\r\nconst diffXAfter = x - centerX;     // 旋转后坐标\r\nconst diffYAfter = y - centerY;     // 旋转后坐标\r\n\r\nconst angleBefore = Math.atan2(diffYBefore, diffXBefore) / Math.PI * 180;\r\nconst angleAfter = Math.atan2(diffYAfter, diffXAfter) / Math.PI * 180;\r\n\r\n// 旋转的角度\r\nthis.rotate = currentGraph.rotate + angleAfter - angleBefore;\r\n复制代码计算缩放尺寸的代码如下：\r\n// 放大 或 缩小\r\nthis.x = currentGraph.x - (x - px);\r\nthis.y = currentGraph.y - (x - px);作者：jasondu链接：https://juejin.im/post/5b8d305151882542ee717ea6"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "article_content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "【微信小程序】性能优化 ", "author": "Rolan", "pub_time": "2018-7-17 00:38", "article_content": "内容整理于微信公开课\r\n为什么要做性能优化？\r\n一切性能优化都是为了体验优化\r\n1. 使用小程序时，是否会经常遇到如下问题？\r\n\r\n\r\n打开是一直白屏\r\n\r\n\r\n打开是loading态，转好几圈\r\n\r\n\r\n我的页面点了怎么跳转这么慢？\r\n\r\n\r\n我的列表怎么越滑越卡？\r\n\r\n\r\n2. 我们优化的方向有哪些？\r\n\r\n\r\n启动加载性能\r\n\r\n\r\n渲染性能\r\n\r\n\r\n3. 启动加载性能\r\n1. 首次加载\r\n你是否见过小程序首次加载时是这样的图？\r\n\r\n这张图中的三种状态对应的都是什么呢？\r\n小程序启动时，微信会为小程序展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包。\r\n2. 加载顺序\r\n小程序加载的顺序是如何？\r\n微信会在小程序启动前为小程序准备好通用的运行环境。这个运行环境包括几个供小程序使用的线程，并在其中完成小程序基础库的初始化，预先执行通用逻辑，尽可能做好小程序的启动准备。这样可以显著减少小程序的启动时间。\r\n\r\n通过2，我们知道了，问题1中第一张图是资源准备（代码包下载）；第二张图是业务代码的注入以及落地页首次渲染；第三张图是落地页数据请求时的loading态（部分小程序存在）\r\n3. 控制包大小\r\n提升体验最直接的方法是控制小程序包的大小，这是最显而易见的\r\n\r\n\r\n勾选开发者工具中“上传代码时，压缩代码”选项；\r\n\r\n\r\n及时清理无用的代码和资源文件（包括无用的日志代码）\r\n\r\n\r\n减少资源包中的图片等资源的数量和大小（理论上除了小icon，其他图片资源从网络下载），图片资源压缩率有限\r\n\r\n\r\n从开发者的角度看，控制代码包大小有助于减少小程序的启动时间。对低于1MB的代码包，其下载时间可以控制在929ms（iOS）、1500ms（Android）内。\r\n4. 采用分包加载机制\r\n根据业务场景，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载；\r\n\r\n使用分包时需要注意代码和资源文件目录的划分。启动时需要访问的页面及其依赖的资源文件应放在主包中。\r\n5 采用分包预加载技术\r\n在4的基础上，当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包，而是可以根据后期数据，做子包预加载，将用户在当先页可能点击的子包页面先加载，当用户点击后直接跳转；\r\n\r\n这种基于配置的子包预加载技术，是可以根据用户网络类型来判断的，当用户处于网络条件好时才预加载；是灵活可控的\r\n6. 采用独立分包技术\r\n目前很多小程序主包+子包（2M+6M）的方式，但是在做很多运营活动时，我们会发现活动（红包）是在子包里，但是运营、产品投放的落地页链接是子包链接，这是的用户在直达落地时，必须先下载主包内容（一般比较大），在下载子包内容（相对主包，较小），这使得在用户停留时间比较短的小程序场景中，用户体验不是很好，而且浪费了很大部分流量；\r\n\r\n可以采用独立分包技术，区别于子包，和主包之间是无关的，在功能比较独立的子包里，使用户只需下载分包资源；\r\n7. 首屏加载的优化建议\r\n7.1 提前请求\r\n异步请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据；当然，如果能在前置页面点击跳转时预请求当前页的核心异步请求，效果会更好；\r\n7.2 利用缓存\r\n利用storage API, 对变动频率比较低的异步数据进行缓存，二次启动时，先利用缓存数据进行初始化渲染，然后后台进行异步数据的更新，这不仅优化了性能，在无网环境下，用户也能很顺畅的使用到关键服务；\r\n7.3 避免白屏\r\n可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据--> 详情页），没有数据的模块可以进行骨架屏的占位，使用户不会等待的很焦虑，甚至走了；\r\n7.4 及时反馈\r\n及时的对需要用户等待的交互操作进行反馈，避免用户以为小程序卡了，无响应\r\n\r\n渲染性能优化\r\n1. 小程序渲染原理\r\n双线程下的界面渲染，小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。\r\n\r\n分析这个流程不难得知：页面初始化的时间大致由页面初始数据通信时间和初始渲染时间两部分构成。其中，数据通信的时间指数据从逻辑层开始组织数据到视图层完全接收完毕的时间，数据量小于64KB时总时长可以控制在30ms内。传输时间与数据量大体上呈现正相关关系，传输过大的数据将使这一时间显著增加。因而减少传输数据量是降低数据传输时间的有效方式。\r\n\r\n2. 避免使用不当setData\r\n在数据传输时，逻辑层会执行一次JSON.stringify来去除掉setData数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将setData所设置的数据字段与data合并，使开发者可以用this.data读取到变更后的数据。因此，为了提升数据更新的性能，开发者在执行setData调用时，最好遵循以下原则：\r\n2.1 不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用；\r\n\r\n2.2 数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据；\r\n\r\n2.3 与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下\r\n\r\n提升数据更新性能方式的代码示例\r\nPage({\r\n  onShow: function() {\r\n\r\n    // 不要频繁调用setData\r\n    this.setData({ a: 1 })\r\n    this.setData({ b: 2 })\r\n    // 绝大多数时候可优化为\r\n    this.setData({ a: 1, b: 2 })\r\n\r\n    // 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在data外\r\n    this.setData({\r\n      myData: {\r\n        a: '这个字符串在WXML中用到了',\r\n        b: '这个字符串未在WXML中用到，而且它很长…………………………'\r\n      }\r\n    })\r\n    // 可以优化为\r\n    this.setData({\r\n      'myData.a': '这个字符串在WXML中用到了'\r\n    })\r\n    this._myData = {\r\n      b: '这个字符串未在WXML中用到，而且它很长…………………………'\r\n    }\r\n\r\n  }\r\n})\r\n复制代码2.4 切勿在后台页面进行setData\r\n在一些页面会进行一些操作，而到页面跳转后，代码逻辑还在执行，此时多个webview是共享一个js进程；后台的setData操作会抢占前台页面的渲染资源；\r\n\r\n\r\n3. 用户事件使用不当\r\n视图层将事件反馈给逻辑层时，同样需要一个通信过程，通信的方向是从视图层到逻辑层。因为这个通信过程是异步的，会产生一定的延迟，延迟时间同样与传输的数据量正相关，数据量小于64KB时在30ms内。降低延迟时间的方法主要有两个。\r\n1.去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数；\r\n2.事件绑定时需要传输target和currentTarget的dataset，因而不要在节点的data前缀属性中放置过大的数据。\r\n\r\n4. 视图层渲染原理\r\n4.1首次渲染\r\n初始渲染发生在页面刚刚创建时。初始渲染时，将初始数据套用在对应的WXML片段上生成节点树。节点树也就是在开发者工具WXML面板中看到的页面树结构，它包含页面内所有组件节点的名称、属性值和事件回调函数等信息。最后根据节点树包含的各个节点，在界面上依次创建出各个组件。\r\n\r\n在这整个流程中，时间开销大体上与节点树中节点的总量成正比例关系。因而减少WXML中节点的数量可以有效降低初始渲染和重渲染的时间开销，提升渲染性能。\r\n简化WXML代码的例子\r\n<view data-my-data=\"{{myData}}\"> \r\n  <view class=\"my-class\" data-my-data=\"{{myData}}\" bindtap=\"onTap\">\r\n    <text> \r\n      {{myText}}\r\n    text>\r\n  view>\r\nview>\r\n\r\n\r\n\r\n<view class=\"my-class\" data-my-data=\"{{myData}}\" bindtap=\"onTap\">\r\n  {{myText}}\r\nview>\r\n复制代码4.2 重渲染\r\n初始渲染完毕后，视图层可以多次应用setData的数据。每次应用setData数据时，都会执行重渲染来更新界面。初始渲染中得到的data和当前节点树会保留下来用于重渲染。每次重渲染时，将data和setData数据套用在WXML片段上，得到一个新节点树。然后将新节点树与当前节点树进行比较，这样可以得到哪些节点的哪些属性需要更新、哪些节点需要添加或移除。最后，将setData数据合并到data中，并用新节点树替换旧节点树，用于下一次重渲染。\r\n\r\n在进行当前节点树与新节点树的比较时，会着重比较setData数据影响到的节点属性。因而，去掉不必要设置的数据、减少setData的数据量也有助于提升这一个步骤的性能。\r\n5. 使用自定义组件\r\n自定义组件的更新只在组件内部进行，不受页面其他不能分内容的影响；比如一些运营活动的定时模块可以单独抽出来，做成一个定时组件，定时组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用。\r\n\r\n6. 避免不当的使用onPageScroll\r\n每一次事件监听都是一次视图到逻辑的通信过程，所以只在必要的时候监听pageSrcoll\r\n\r\n总结\r\n小程序启动加载性能\r\n\r\n\r\n控制代码包的大小\r\n\r\n\r\n分包加载\r\n\r\n\r\n首屏体验（预请求，利用缓存，避免白屏，及时反馈\r\n\r\n\r\n小程序渲染性能\r\n\r\n\r\n避免不当的使用setData\r\n\r\n\r\n合理利用事件通信\r\n\r\n\r\n避免不当的使用onPageScroll\r\n\r\n\r\n优化视图节点\r\n\r\n\r\n使用自定义组件"}
{"title": "微信小程序适配 iPhone X 总结 ", "author": "Rolan", "pub_time": "2018-7-26 00:03", "article_content": "本文主要介绍我们的知识小集小程序在适配 iPhone X 屏幕时遇到的一些问题以及总结，希望对你的小程序开发能有所帮助。iPhone X 屏幕数据在去年 9 月份 iPhone X 正式发布后，引发了一波 iOS App 适配 iPhone X 的热潮和技术文章，详情可以参考掘金技术社区的这个专题： 《iPhone X 适配实践》我们这里先简单总结一下 iPhone X 屏幕的基础数据，方便后续在小程序开发中进行适配。屏幕尺寸：5.8 英寸（对角线）屏幕物理分辨率：1125px × 2436px，458 ppi实际开发适配尺寸：375pt × 812pt，@3x此外，由于在 iPhone X 屏幕顶部状态栏区域有“齐刘海”，以及在屏幕底部增加了“操作条”，如下图所示，因此，我们在开发中需要注意 安全区域 的问题。根据苹果官方的文档，iPhone X 顶部状态栏的适配安全区域的高度为 44pt，底部操作条区域的高度为 34pt。另外，在 iPhone X 中，一些系统 Bar 的默认高度相比于之前的设备也发生了变化，如下表所示。所以在 iOS App 开发中，如果我们使用系统默认的 UINavigationController 和 UITabBarController 时，则无需额外的适配工作，iOS 系统会自动适配好相关 Bar 的安全区域问题。如果我们使用了自定义的导航栏和标签栏，则需要注意根据设备类型区分设置这些 Bar 的不同高度。小程序的尺寸单位为了解决不同屏幕尺寸的适配问题，小程序自己定了一个尺寸单位：rpx（responsive pixel），它可以根据屏幕宽度进行自适应。小程序中规定， 所有设备的屏幕宽度都为 750rpx ，根据设备屏幕实际宽度的不同，1rpx 所代表的实际像素值也不一样。根据 微信开发文档 ，在 4.7 英寸的 iPhone 设备上（iPhone 6/7/8），屏幕宽度为 375px（此处应该理解为 375 point），共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1物理像素。小程序中如何判断设备为 iPhone X上面我们简要介绍了 iPhone X 的屏幕数据和小程序中的尺寸单位作为铺垫，现在终于要切入正题了，要在小程序中适配 iPhone X 屏幕，首先我们需要知道如何判断设备类型。微信的小程序 API 中提供了一个 wx.getSystemInfo(OBJECT) 方法用于获取用户手机的系统信息和设备信息，包含如下数据：上述每个字段的含义详见 文档 ，我们不再一一赘述。因此，我们可以根据该方法返回的手机型号字段 model 是否包含 iPhone X 字符串来判断设备是否为 iPhone X，也可以根据 screenHeight 的高度是否等于 812 来判断。NOTE:这里有一个小坑需要注意，在微信开发者工具中的模拟器，如果选择为 iPhone X，此时获取到的 model 值为 iPhone X ，导致我以为真机也是这个值，于是直接用 if (model == 'iPhone X') 来判断，但其实真机下 model 的值为这种格式： iPhone X (GSM+CDMA)<iPhone10,3> ，因此我们需要用字符串检索匹配进行判断。综上，我们可以在 app.js 的 globalData 中添加一个字段 isIPX 用于标识当前设备是否为 iPhone X，然后在小程序启动时 onLaunch 中调用 wx.getSystemInfo(OBJECT) 方法并在其 success回调中读取 model 字段进行分析，代码大致如下：App({\r\n  // 全局数据\r\n  globalData: {\r\n    // 其他数据定义 ...\r\n    \r\n    isIPX: false, // 当前设备是否为 iPhone X\r\n  },\r\n  \r\n  // 小程序启动入口\r\n  onLaunch: function (options) {\r\n    // 其他启动代码...\r\n    \r\n    // 判断设备是否为 iPhone X\r\n    this.checkIsIPhoneX()\r\n  },\r\n  \r\n  checkIsIPhoneX: function() {\r\n    const self = this\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        // 根据 model 进行判断\r\n        if (res.model.search('iPhone X') != -1) {\r\n          self.globalData.isIPX = true\r\n        }\r\n        // 或者根据 screenHeight 进行判断\r\n        // if (res.screenHeight == 812) {\r\n        //   self.globalData.isIPX = true\r\n        // }\r\n      }\r\n    })\r\n  },\r\n}\r\n如果需要小程序启动时立即获取设备相关信息，也可以调 wx.getSystemInfoSync() 方法，它会同步获取数据并立即返回。页面适配实战在小程序页面开发中，涉及到需要适配 iPhone X 的地方主要有：导航栏（NavigationBar），标签栏（TabBar）以及页面底部的吸底按钮。导航栏和标签栏适配如果我们使用微信小程序官方组件进行开发，没有进行自定义，在 app.json 文件中设置 tabBar 页面，且 window 的 navigationStyle 值为 default ，那么我们无需在 iPhone X 中对导航栏和标签栏进行适配，微信会自动帮我们适配好，如下图为知识小集小程序的首页：但是我们如果是自定义导航栏（在 app.json 文件中设置 window 的 navigationStyle 为 custom ，此时只保留右上角胶囊状的按钮，需要开发者自己画导航栏样式）和标签栏，则我们需要在每个页面中判断设备类型，并针对 iPhone X 屏幕在安全区域内进行布局，并修改相关 Bar 的高度值（见上述表格）。以自定义导航栏适配为例，步骤如下：（1）在每个页面的 page.js 中先读取 app.js 中的 isIPX 值，如下：const app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    // 页面其他数据...\r\n    \r\n    isIPX: app.globalData.isIPX,\r\n  },\r\n  \r\n  // 其他代码\r\n}\r\n（2）然后在 page.wxss 样式文件中对某一个视图 View 分别为普通屏幕和 iPhone X 屏幕写两种样式，如下：.navi-bar-view {\r\n  height: 64px;\r\n  /* 其他样式值 */\r\n}\r\n.navi-bar-view-IPX {\r\n  height: 88px;\r\n  /* 其他样式值 */\r\n}\r\n（3）最后在 page.wxml 页面结构布局中根据 isIPX 的值给 View 设置不同的 class 样式，如下：<view class=\"{{isIPX ? 'navi-bar-view-IPX' : 'navi-bar-view'}}\">\r\n</view>\r\n此外，对于自定义导航栏和标签栏，我建议还是要遵循 iPhone UI 的设计规范，样式可以参考苹果官方的渲染图：吸底按钮适配在小程序页面中，吸底按钮是很常见的一种设计，我们一般会把一些重要的按钮放在页面底部悬浮不动，例如我们知识小集小程序的“小集详情页”底部的“收藏”和“转发”按钮：在 iPhone X 中我们需要把吸底按钮往上偏移 34 像素，可通过在 CSS 样式中设置 padding-bottom 为 34px 实现，参考代码如下：.feed-bottom-view {\r\n  width: 100%;\r\n  height: 48px; /* 吸底按钮的高度 */\r\n  bottom: 0;\r\n  opacity: 0.95;\r\n  position: fixed;\r\n  border-top-style: solid;\r\n  border-top-width: 0.5px; /* 分割线的高度 */\r\n  border-color: lightgrey;\r\n  background-color: #F8F8F8;\r\n}\r\n.feed-bottom-view-IPX {\r\n  /* iPhone X 内容往上偏移 34px */\r\n  padding-bottom: 34px;\r\n}\r\n<view class=\"{{isIPX ? 'feed-bottom-view feed-bottom-view-IPX' : 'feed-bottom-view'}}\">\r\n<!-- 底部吸底按区域 -->\r\n</view>\r\n备注：如前面所述，对于不同设备宽度，1rpx 所代表的实际像素值也不一样，而在不同尺寸的 iPhone 设备（3.5/4.0/4.7/5.5 英寸）中，虽然它们的宽度不同，但其导航栏+状态栏的高度都为 64pt（iPhone X 为 88pt），标签栏 TabBar 的高度都为 49pt（iPhone X 为 83pt）。所以在小程序开发中，当我们需要自定义导航栏、标签栏，或者适配 iPhone X 顶部和底部安全区域时，我建议此处的单位直接使用 px （在小程序中对应 iOS 开发中的点 pt ）而不使用 rpx （当然页面的其他元素的尺寸描述还是推荐使用 rpx ），以确保最终渲染显示的高度与 iOS 系统默认的一致。总结本文简要介绍了在小程序开发中如何适配 iPhone X 屏幕，更多细节请查阅我们在 GitHub 上开源的知识小集小程序的代码： awesome-tips-wx-app"}
{"title": "微信小程序iOS端如何暂停animated动画 ", "author": "Rolan", "pub_time": "2018-8-2 00:03", "article_content": "在知道有 animation-play-state 这个animation的参数时，我内心是激动的。在得知iOS端并不支持时，一股凉意袭来animation-play-state先来介绍一下今天的主角 animation-play-stateanimation-play-stateCSS属性定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。恢复一个已暂停的动画，将从它开始暂停的时候，而不是从动画序列的起点开始在动画。在MDN文档中了解到，这是一个实验中的功能，但是其作用还是强大的。既可以控制/获取元素的动画状态（paused，running）所以，这个animation的参数用来控制动画的播放状态再合适不过了。画外音：你还没考虑兼容性呢！对！就是这个兼容性问题。在chrome上这个参数是可以支持的，但是iOS设备上就不支持了...叹息。在iOS上的处理当然不能因为兼容性问题就不用这个参数了，当然不能让每个iOS用户去下载一个chrome浏览器，当然...那我们怎么解决呢？？？用JS通过 Window.getComputedStyle() 方法，我们可以获取元素实时的 style 的 CSSStyleDeclaration 对象，这个对象表示CSS属性键值对的集合。也就是说我们使用这个方法可以获取一个正在进行动画的元素当前的 style 值。PS:关于 Window.getComputedStyle() 方法的值可以在MDN上了解到，这里不展开叙述。给出一个语法的例子（摘自MDN）let style = window.getComputedStyle(element, [pseudoElt]);\r\n复制代码那么具体要怎么做呢？实现See the Penanimation-play-state by luogao (@luogao) onCodePen.代码已经在上面的codepen预览中展示啦，如果现实不来请点这里:point_right:Roy Luo's codepen大致解释一下就是：在元素的外层的包裹元素上添加获取到的执行动画的元素的 style 计算属性，从而让执行动画的元素暂停下来。那么在微信小程序中又是如何呢？其实，最先遇到这个问题是在做小程序的时候。一个播放器的界面，中间一张专辑图片。在圆形的黑胶唱片边框中旋转。当播放停止，图片也同时停止旋转。 停在当前旋转的位置当时看似简单的一个需求，使用了 animation-play-state 并且与预期一样达到了效果， 在模拟器中 。没错，洋洋得意的以为完成了需求，结果真机（iOS）上一测试，原形毕露。当时看到小程序的官方社区中提到说iOS不支持这个 animation-play-state ‍♂️ ‍♂️ ‍♂️ ‍幸得残阳映枫红在sf的一个问题中的回答让我找到了方向。感谢之～"}
{"title": "mpvue小程序《校友足迹》成长记（一） ", "author": "Rolan", "pub_time": "2018-8-9 00:01", "article_content": "灵感小程序开发进行的热火朝天，自己申请小程序账号也有一段时间了，但是一直没有有所作为，苦于没有一个好点子，不知道该做些什么，基本想到的都有人做了；怎么办？！一次校友聚会后给了我新的想法，因为大家谈到了一个问题，就是怎么把一个城市的校友聚合在一起，回来后我就想到了小程序，现在基本每个人都会有微信，那么就用大家最常用的方式来找到校友，微信小程序即用即走，不用下载，而且受众面很广，很适合来聚合校友；既然想法有了，就开始实际行动吧原型设计灵感来了就开始着手设计基本的原型，最初的功能获取用户位置后，用户选择自己的院校后，可以看到自己学校校友分布的情况，然后可以分享自己校友分布图；最初的原型图很粗糙，未曾美化加工，不过已经上线的版本已经过简单美化，这里使用了原型工具--墨刀的（此处非广告，纯属自己喜欢，哈哈！因为每次做原型图都需要尽快达到自己想要的效果，所以感觉墨刀用起来很顺手），这里的原型图和线上版本会有所差别，后面会提到原因；技术选型前端： 小程序提供了自己的视图层描述语言，但是喜欢折腾的我却不愿意使用，虽说学习起来也很快，但是由于学了后就只能用在小程序开发上，这就让我很不爽（别吐槽:joy:）；既然不用原生的，那么mpvue就进入了我的眼帘，刚好有段时间没有做vue的项目了，这次刚好可以练练手，不仅可以复习一下vue的知识，而且还可以用Vue来做小程序，简直一举两得了（尽管mpvue有很多坑，但是也阻挡不了我使用的心）；服务端： 前端开发选型完毕了，接下来就到服务端的选择了，java做服务明显过重，作为可以用js写服务端的node当然是我首要的选择目标了；接下来为了让自己再重新温习一下mysql的curd，当然选择mysql作为数据库存储数据了；插件： 另外需要用到图表展示，由于工作中经常使用echarts，所以首先想到的是使用它，然而刚开始并不确是否有合适的版本，但是当看到了《在 mpvue 使用 echarts 小程序组件》这篇文章下的评论区时，让我很是激动（这个作者会不会想打我，明明推荐的是 echarts-for-weixin ，可是我却跑到了评论区找到了 mpvue-echarts :joy:），所以这里我采用 ECharts 的 Mpvue 小程序版本 ，感谢此插件的贡献者F-loatok！技术选型完毕项目构建既然原型和技术已经选择完毕，那就开始项目准备工作；前端目录结构由于mpvue已经帮我们搭建了基本的目录结构，所以无需太多的修改，需要哪些页面只要按照规则进行添加即可；服务端目录结构后端服务拆分了全局配置，router，control和sql相关的配置，由于上线前需要https协议，所以这里加了一个https的配置，上线后会在nginx中进行配置；这里不做过多解释；这里可以看到我使用了 pm2 ， pm2 是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。这里附上pm2的使用教程 blog.csdn.net/sunscheung/…数据准备1、由于这个小程序需要中国各个省份和地区，所以需要建立省份与地区的关系，并且需要易于保存，这里省份地区可以很容易在网上找到，而且小程序也提供现成的组件来进行城市地区选择；2、由于是校友，那么就需要整理聚合所有院校的信息了，刚开始只找到了部分院校的数据，而且数据并不是那么全，所以很难保证数据的完整性；后来通过 中华人民共和国教育部的网站 ，终于找到了最新的院校信息；（截至2017年5月31日，全国高等学校共计2914所，其中：普通高等学校2631所（含独立学院265所），成人高等学校283所。）后来经过其他渠道，找到了香港，台湾，澳门院校34所，所以共计2941所；数据是找到了，但是数据清洗工作却是最为繁琐的，通过筛选和清洗后整理了如下形式，然后依据此形式导入数据库中；既然已经分享这篇文章，那么我就奔着资源共享的原则，如果有需要这些整理好的院校数据的，可以在下方留言，我会把数据发到你的邮箱；功能点1、用户打开小程序后，获取用户的经纬度信息，并根据经纬度信息返回用户所在城市；2、用户确定所在城市后，搜索院校，搜索院系支持模糊搜索功能；3、院校选择完毕后，跳转此院校校友分布情况，并显示top5城市；4、分享自己校友分布情况；采坑点1、由于线上小程序不允许调用授权域名以外的接口，所以需要在服务端实现调用腾讯位置服务api接口，来实现返回用户位置信息；2、由于目前wx.getUserInfo() 接口有调整，使用该接口将不再出现授权弹窗，请使用 <button open-type=\"getUserInfo\"></button> 引导用户主动进行授权操作，所以现在获取用户基本信息并没有那么容易了，因此需要用户在下一步操作时引到用户进行授权；（这里只是获取用户的昵称和头像信息，没有任何隐私信息）3、由于 mpvue-echarts 还存在一些小的问题，所以当一个页面有两个实例的时候，我的map表就无法点击查看当前城市的人数了；弃用功能1、由于在小范围测试阶段，我发现用户很少会在第一屏页面等待定位完成，而是直接下一步操作，这就导致无法存储用户的位置信息；所以后来我就直接弃用第一屏，直接在服务端处理用户的定位操作并保存，用户只需填写自己的院校即可进入查看分布情况页面；这样也简化了用户的操作步骤，同时也解决了无法保存用户位置的尴尬局面上线版本1、由于没有大面积用户，所以生成的图表并没有那么好看（希望掘金的朋友能够捧捧场，哈哈！后面我会把源代码进行分享的）；我只做了部分假数据进行参考，请勿见怪！后续下一篇文章我将会分享源代码供大家参考，同时也希望大家多提提建议；体验也可在小程序搜索栏搜索---‘校友足迹’，你的使用将会给我带来无比的荣誉，期待你们的到来，谢谢"}
{"title": "小程序居然可以用WXS模拟实现过滤器！ ", "author": "Rolan", "pub_time": "2018-8-15 00:05", "article_content": "小程序目前官方还没有出过滤器，特别不方便，但是可以用wxs来模拟过滤器，话不多说，直接上代码。当然，不熟悉wxs的可以先看一下 官方文档1.新建一个filter.wxs的文件我个人建议是一个过滤器写一个wxs，避免引用用不到的过滤器，不过都写到一个里面也是可以的。2.在filter.wxs里写需要的方法（我这里以订单状态为例）3.在需要的wxml里引入filter.wxs<wxs module=\"_orderFilter\" src=\"../../filter/orderStatus.wxs\"></wxs>\r\n\r\n<view>\r\n    {{_orderFilter.orderStatus(order.status)}}\r\n</view>这样就ok啦～作者：我是敏敏啦链接：https://juejin.im/post/5b7148da51882560fd2340c7"}
{"title": "转转：微信小程序分包加载实战 ", "author": "Rolan", "pub_time": "2018-8-21 00:13", "article_content": "微信小程序采用的是类似离线包加载方案，以 转转小程序 为例，当用户第一次打开时会先下载好所有代码，然后再加载页面；当用户再次进入转转小程序时，会直接使用已下载的代码，省去了代码下载的过程，打开速度更快。看似很美好的设计，但有两个问题：第一次打开转转小程序时白屏时间很长，因为要下载接近2.5M的代码量，也就是说你的代码越多，白屏时间越长，而转转APP采用的网页离线机制体验更佳：在用户打开APP时就下载/更新离线包，这样在用户进入对应的网页时，代码已经下载好了，没有漫长的白屏过程。代码有部分更新时，没办法进行增量更新，导致每次发版后，用户都需要重新下载全部代码问题看似不大，但对转转有很大影响，例如进行微信广告投放时，用户从点击广告到加载第一个页面之间的流失率竟能到达 40% ，这显然是 FE 无法接受的性能，而小程序分包加载机制能够在一定程度上解决上述问题。分包加载小程序的分包加载机制实际上是离线包和 M 页的一种结合机制，即你可以把代码划分成主包 +N 个分包，官方定义：在小程序启动时，默认会下载主包并启动主包内页面，如果用户需要打开分包内某个页面，客户端会把对应分包下载下来，下载完成后再进行展示。总结如下：打开小程序，默认先加载主包进入分包页面时，再加载对应分包这样的好处是进入主包页面时，需要下载的代码量小了很多，白屏时间更短，体验更佳。特性1.7.3 及以上基础库开始支持，不支持的版本默认使用整包的方式整个小程序所有分包大小不超过 4M，单个分包/主包大小不能超过 2M分包数量目前没有限制，也就是说你可以放 N 个分包，甚至每个页面一个分包入口页面 / Tab 页面必须在主包里关于主包第一次进入小程序，默认下载主包代码分包以外的所有代码，都会被打入主包分包内代码可以引用主包内代码关于分包因为存在资源依赖关系，微信的机制是先下载主包，后下载分包分包目录不能在主包目录下面分包可以引用自己包内、主包内的资源，不能引用其他分包内的资源坑小程序的打包机制仅仅是根据文件目录打包，分包内require/import的任何文件，只要不在同一个目录下面，都不会被打进分包，也就是说，类库及一些公共文件，只能放在主包里面，如果主包分包划分不好的话，主包的大小也很难降下来安卓系统进入分包页面时，会出现一个丑陋的系统级的loading层，这一定程度上影响了安卓的体验转转的分包加载转转小程序在使用分包之前，压缩后的代码量大概是2.45M，也就是说，每个新用户第一次都需要下载的2.45M代码才能进入页面，使用分包机制后，主包大小降为1M左右，也就是说，如果是进入主包页面， 下载时间大约降低了60%文件结构：├── libs\r\n├── components\r\n├── pages  主包根目录\r\n├────index 首页\r\n├────post  发布页\r\n├────...\r\n├── subPages  分包根目录\r\n├────trade    交易分包\r\n├────mine     我的页面分包\r\n├────...\r\n复制代码我们根据用户访问的轨迹，分成了 20 个左右的分包。 例如 trade 包，里面包含详情页、下单页、支付页、支付成功页等，这条线的页面，用户可能不需要一进入小程序就使用，但一旦使用可能是使用整个链条，因此可以作为一个分包。历史入口兼容一个页面放入分包之后，路径会发生变化，例如详情页由 /pages/detail 变为 /subPages/trade/detail，意味着如果用户访问了以前的 page 则得不到正确的页面响应（例如：分享出去的小程序卡片、二维码、公众号推送消息等），这些静态不可改变的历史入口怎么办？我们目前采用如下方案：原来主包内的每个页面都保留，但代码只保留跳转逻辑，用户进来后立即跳到对应的分包页面，用户几乎是无感知的这样也会产生一点小问题：这些跳转页面也占用一定的空间，接下来我们会优化成在 onLaunch、页面跳转时进行判断，直接跳入正确的分包页面。以上是转转在分包加载方面的实战记录，欢迎小程序开发者与我们交流经验。另外，本文作者 转转前端负责人 张所勇，也会在掘金开发者大会・微信小程序专场分享转转小程序开发经验，演讲主题是「小程序 WebView 应用实践」。"}
{"title": "制作todo list微信小程序 ", "author": "Rolan", "pub_time": "2018-8-27 00:16", "article_content": "今天给大家分享如何制作todo list微信小程序。资源视频 - BiliBili，制作ToDo List微信小程序http://v.youku.com/v_show/id_XMzc5NjgwMDM5Ng==.html， YouTube源码地址 - https://github.com/JKooll/sha...工具微信开发者工具 v1.02微信小程序框架文档weui for 小程序 基础样式库过程打开微信开发工具，创建新项目导入weui for 小程序 基础样式库下载weui for 小程序源码在项目中创建目录src/wxss/复制dist/style/weui.wxss文件到项目src/wxss/目录下在全局引入weui基础样式库打开app.wxss文件添加代码到开头@import './src/wxss/weui.wxss';创建todo页面打开app.json在pages数组第一行中添加pages/todo/todo,保存文件添加tasks数据打开pages/todo/todo.js在data对象中添加tasks数据tasks每个元素包含三个字段：content: 内容key: 键status: true - 完成状态， false - 未完成状态渲染tasks列表打开pages/todo/todo.wxml清空文件添加如下代码到文件， 保存文件<view class=\"page\">\r\n\r\n  <view class=\"page__bd\">\r\n\r\n    <view class=\"weui-cell\">\r\n      <view class=\"weui-cell__bd\">\r\n        <input class=\"weui-input\" placeholder=\"添加新任务\"/>\r\n      </view>\r\n\r\n      <view class=\"weui-cell__ft\">\r\n        <button class=\"weui-btn\" type=\"primary\">添加</button>\r\n      </view>\r\n    </view>\r\n\r\n    <view class=\"weui-cells__title\">待办事项</view>\r\n    <view class=\"weui-cells weui-cells__after-title\">\r\n      <radio-group>\r\n\r\n        <block wx:for=\"{{tasks}}\" wx:key=\"value\" wx:if=\"{{!item.status}}\">\r\n          <label class=\"weui-cell weui-check__label\">\r\n            <radio class=\"weui-check\" value=\"{{item.value}}\"></radio>\r\n\r\n            <view class=\"weui-cell__hd weui-check__hd_in-checkbox\">\r\n              <icon class=\"weui-icon-checkbox_circle\" type=\"circle\" size=\"23\" wx:if=\"{{!item.checked}}\"></icon>\r\n            </view>\r\n            <view class=\"weui-cell__bd\">{{item.content}}</view>\r\n\r\n            <view class=\"weui-cell__ft\"><button class=\"weui-btn\" type=\"warn\">删除</button></view>\r\n          </label>\r\n        </block>\r\n        \r\n      </radio-group>\r\n    </view>\r\n\r\n    <view class=\"weui-cells__title\">完成事项</view>\r\n    <view class=\"weui-cells weui-cells__after-title\">\r\n      <radio-group>\r\n\r\n        <block wx:for=\"{{tasks}}\" wx:key=\"value\" wx:if=\"{{item.status}}\">\r\n          <label class=\"weui-cell weui-check__label\">\r\n            <radio class=\"weui-check\" value=\"{{item.value}}\"></radio>\r\n\r\n            <view class=\"weui-cell__hd weui-check__hd_in-checkbox\">\r\n              <icon class=\"weui-icon-checkbox_success\" type=\"success\" size=\"23\"></icon>\r\n            </view>\r\n\r\n            <view class=\"weui-cell__bd\">{{item.content}}</view>\r\n\r\n            <view class=\"weui-cell__ft\"><button class=\"weui-btn\" type=\"warn\">删除</button></view>\r\n          </label>\r\n        </block>\r\n        \r\n      </radio-group>\r\n    </view>\r\n    \r\n  </view>\r\n\r\n</view>改变task状态打开pages/todo/todo.wxml待办事项和完成事项下的label更改为<label class=\"weui-cell weui-check__label\" data-value=\"{{item.value}}\" bindtap=\"changeTaskStatus\">bindtap=\"changeTaskStatus\" 绑定点击事件data-value=\"{{item.value}}\" 将task的value值传递给changeTaskStatus函数打开pages/todo/todo.js, 添加changeTaskStatus, 保存文件查看效果changeTaskStatus: function (e) {\r\n    let value = e.currentTarget.dataset.value;\r\n\r\n    let tasks = this.data.tasks;\r\n\r\n    let index = tasks.findIndex(task => task.value == value);\r\n\r\n    if (index < 0) {\r\n      return;\r\n    }\r\n\r\n    tasks[index].status = !tasks[index].status;\r\n\r\n    this.setData({\r\n      tasks: tasks\r\n    });\r\n  }删除task打开pages/todo/todo.wxml待办事项和完成事项下的button更改为button class=\"weui-btn\" type=\"warn\" data-value=\"{{item.value}}\" catchtap=\"removeTask\">删除</button>catchtap=\"removeTask\" 绑定点击事件，和bindtap区别在于它阻止事件冒泡 【更多】data-value=\"{{item.value}}\" 将task的value值传递给removeTask函数打开pages/todo/todo.js, 添加removeTask函数, 保存文件查看效果添加task创建task打开pages/todo/todo.wxml将添加新任务下的input更改为<input class=\"weui-input\" placeholder=\"添加新任务\" bindinput=\"typeNewTask\" value=\"{{newTask}}\"/>bindinput=\"typeNewTask\" 绑定input事件value=\"{{newTask}}\" 绑定newTask到input valu，可以用来初始化input中的内容打开pages/todo/todo.js在data对象中添加两个新的变量, newTask: '', key: ''newTask 保存新的task的内容key 保存下一个task value值添加typeNewTask，更新newTask变量的值typeNewTask: function(e) {\r\n    this.setData({\r\n      newTask: e.detail.value.trim()\r\n    });\r\n  },保存task打开pages/todo/todo.wxml将添加新任务下的button更改为<button class=\"weui-btn\" type=\"primary\" bindtap=\"addTask\" disabled=\"{{newTask == ''}}\">添加</button>bindtap=\"addTask\" 绑定点击事件disabled=\"{{newTask == ''}}\" 当newTask为空时，禁用button打开pages/todo/todo.js清空data中tasks变量的内容， tasks: []添加addTask函数，保存文件查看效果addTask: function () {\r\n    let tasks = this.data.tasks;\r\n    let key = this.data.key;\r\n\r\n    let newTaskObj = { content: this.data.newTask, value: key++, status: false };\r\n    tasks.push(newTaskObj);\r\n\r\n    this.setData({\r\n      tasks: tasks,\r\n      key: key,\r\n      newTask: ''\r\n    });\r\n  },完成作者：jkol原文：https://segmentfault.com/a/1190000016151643"}
{"title": "小程序之canvas图片及文本适配 ", "author": "Rolan", "pub_time": "2018-9-3 00:32", "article_content": "场景需求小程序目前不支持直接分享到朋友圈，所以对于有分享到朋友圈的需求，一般是生成一张图片，例如，生成一张带有小程序码的图片，用户可以将这张图片保存到手机本地，然后将这张图片分享到朋友圈。这张图片需要使用canvas画出来。今天我们不讲怎么生成码，这个一般是后端封装一个API，前端通过调用API得到一个小程序码的url，通过image去画到canvas上，跟在canvas上画一个image是一样的逻辑。这篇文章主要是讲怎么在canvas上适配图片和文字，也就是怎么将图片和文本画到canvas上的正确的位置，能在不同的手机上都能正确的展示。效果图展示（以下图片是在微信开发者工具中显示的） 这里演示的Demo是： “选择图片”button选择一张图片，可以居中显示在以下图中的黄色区域，即canvas中，并在canvas的顶部居中展示文本“你若盛开，蝴蝶自来”。以下是两个不同尺寸的图片画在canvas上，分别在iphone5、iphone6、iphone6 plus上的展示效果图。这里的猫图片的原始尺寸：658*658这里的girl图片的原始尺寸是：700*699代码说明小程序尺寸单位小程序尺寸单位2. wxml<button bindtap=\"chooseImg\">选择图片</button><view class=\"canvas-box\">    <canvas class=\"canvas\" canvas-id=\"shareCanvas\" bindlongtap=\"saveShareImage\"></canvas></view>$3. scss（wxss） 这里我用的是scss去写样式代码，在webStorm中可以通过配置，将scss解析成wxss，至于具体怎么配置，可以自行百度。 PS1：这里定义了一个scss rpx function，是因为在webStrom中格式化代码的时候会将数字和单位rpx中间添加一个空格，导致编译报错，所以用一个function去处理 PS2：样式说明（设计稿是基于iphone6视觉稿标准）： button宽高：700rpx * 92rpx (350px * 46px) 包裹canvas的容器的view（.canvas-box）position:fixed,占据除顶部button的高度之外，填满剩余全部空间，canvas居中显示，宽高：700rpx， 100%@function rpx($value) {  @return $value*1rpx;}page {  background-color: #fff6f6;  button {    width: rpx(700);    height: rpx(92);    background-color: #ffddab !important;  }  .canvas-box {    position: fixed;    top: rpx(92);    left: 0;    right: 0;    bottom: 0;    canvas {      position: absolute;      width: rpx(700);      height: 100%;      top: 50%;      left: 50%;      transform: translate(-50%, -50%);    }  }}$4. js 1、在data中定义三个变量data: {        windowWidth: 0, // 可使用窗口宽度        windowHeight: 0, // 可使用窗口高度        ratio: 0 // 根据尺寸动态计算 1px换算成多少rpx    }2、通过wx.getSystemInfo获得系统信息，并且计算ratio    onReady: function (e) {        // 获取系统信息        wx.getSystemInfo({            success: res => {                console.log(res);                this.setData({                    windowWidth: res.windowWidth,                    windowHeight: res.windowHeight,                });                this.setData({                    // 屏幕宽度 375px = 750rpx，1px=2rpx                    // 1px = （750 / 屏幕宽度）rpx；                    // 1rpx = （屏幕宽度 / 750）px;                    ratio: 750 / this.data.windowWidth                });            }        });    },3、button的触发事件chooseImg，通过wx.chooseImage选择图片，通过wx.getImageInfo获取选择的图片的大小chooseImg: function () {        wx.chooseImage({            count: 1,            success: res => {                let imgUrl = res.tempFilePaths[0];                // 获取图片大小                wx.getImageInfo({                    src: imgUrl,                    success: data => {                        let imgWidth = data.width;                        let imgHeight = data.height;                        // 创建canvas，根据选择的图片大小，在canvas上绘制图片和文字                        this.createCanvasShareImage(imgUrl, imgWidth, imgHeight);                    }                });            }        });    }4、创建canvas并在canvas上添加图片和文本 createCanvasShareImage: function (imgUrl, imgW, imgH) {        // 使用wx.createCanvasContext获取绘图上下文 context        let context = wx.createCanvasContext('shareCanvas');        console.log('context: ', context);        // 获取canvas的宽度：        // 750的设计稿基于iphone6的尺寸（屏幕宽度： 375px）在小程序中的比例是： 1px = 2rpx ==> 375px = 750rpx ==> 屏幕宽度(px) = 750rpx        // 所以 1rpx = 屏幕宽度 / 750        // 我们这里css中设置的 canvas 的width：700rpx, 所以 canvas的宽度计算是： [（屏幕宽度 / 750）* 700]rpx， 这样就可以做到在不同手机上都可以适配        let canvasWidthPx = 700 / this.data.ratio;        // 设置 canvas 的背景并填充canvas        context.fillStyle = '#ffdc22';        context.fillRect(0, 0, canvasWidthPx, this.data.windowHeight);        // 绘制图片：图片居中显示在 canvas 中        let imgX = (700 - imgW) / 2;        let imgY = (this.data.windowHeight * this.data.ratio - 46 * this.data.ratio - imgH) / 2;        let clipWidth = imgW * this.data.ratio;        let clipHeight = imgH * this.data.ratio;        context.drawImage(imgUrl, -imgX, -imgY, clipWidth, clipHeight, 0, 0, imgW, imgH);        // 设置字体大小、文本颜色        context.setFontSize(20);        context.fillStyle = \"#000\";        // 计算文本的宽度：measureText() 取到文本的 width        let txtWidth = context.measureText('你若盛开，蝴蝶自来').width;        // 绘制居中文本：这个地方的 (x, y)的坐标是在文本的左下角位置        context.fillText(\"你若盛开，蝴蝶自来\", (canvasWidthPx - txtWidth) / 2, 20 * this.data.ratio);        context.draw();    }5、长按bindlongtapcanva保存图片或者直接预览图片，先通过wx.canvasToTempFilePath将当前画布指定区域的内容导出生成指定大小的的图片，再通过wx.saveImageToPhotosAlbum将图片保存到本地，或者通过wx.previewImage直接预览图片。    saveShareImage() {        wx.canvasToTempFilePath({            canvasId: 'shareCanvas',            success: (res) => {                console.log('canvasToTempFilePath： ', res);                // 将图片保存到相册                wx.saveImageToPhotosAlbum({                    filePath: res.tempFilePath,                    success: (data) => {                        console.log(data);                    }                });                // 直接预览图片                wx.previewImage({                    urls: [res.tempFilePath]                })            }        })    }真机效果图显示（一加六手机） 一加6手机显示的小程序效果图.png保存到手机本地的图片.png作者：豆豆的故事 链接：https://www.jianshu.com/p/75fa54f6caa8"}
{"title": "mpvue写一个CPASS小程序 ", "author": "Rolan", "pub_time": "2018-9-4 00:06", "article_content": "本文是对CPASS项目的技术要点和所踩的坑做一些总结。项目一个提供移动办公场地的小程序平台。使用美团mpvue框架， mpvue：1.0.13, mpvue-loader：1.0.15 静态资源（除了tabbar图标）放在阿里云oss组件（页面）间通信四种方式：Vuex状态管理（mapActions，mapGetters）本地缓存（setStorage，getStorage，removeStorage）Bus集中式的事件中间件（$emit，$on，$off）路由query传值这里说一下比较少用的第三种通信方式。Bus应用于非父子组件通信，利用$emit，$on，$off分别来分发、监听、取消监听。第一步：在mixins（混合）建一个文件event-bus.jsimport Vue from 'vue';\r\nexport default new Vue();复制代码第二步：在需要分发的组件中引入event-bus，再传递分发事件import Bus from '@/mixins/event-bus'\r\n\r\n// 需要传递给兄弟组件的值\r\nlet params = { \r\n    ***\r\n}\r\nBus.$emit('getParams', params)\r\n\r\n复制代码第三步：在需要监听的组件中引入event-bus，在created周期去监听事件（小程序周期监听无效）,在 beforeDestroy 周期取消监听事件import Bus from '@/mixins/event-bus'\r\ncreated () {\r\n  // 监听事件\r\n  Bus.$on('getParams', params => {\r\n    // to do something\r\n\r\n  })\r\n},beforeDestroy () {\r\n  // 清除监听\r\n  Bus.$off('getParams');\r\n}复制代码swiper选项卡 +  无限加载利用微信官方提供的swiper封装一个无限数据加载的swiperTab选项卡。空态下：技术难点：swiper需要设置固定高度，触底 onReachBottom 无限加载又需要高度。所以需要在swiper标签设置动态高度 :style=\"{height: swiperHeight + 'px'}\" 。 onLoad 周期获取单个list-item的高度。假如所渲染数据有n组数据，则swiper高度为： swiperHeight = baseHeight * n + 加载提示占位高度 。// swiper动态设置高度，list为需要渲染的数据\r\nautoHeight(list) {\r\n  let num = list.length;\r\n  // this.loadHeight加载提示语的高度\r\n  let listHeight = this.baseItemHeight * num + this.loadHeight\r\n  this.swiperHeight = Math.max(this.windowHeight, listHeight);\r\n},\r\n// 获取静态高度\r\ncalcStaticHeight() {\r\n  return new Promise((resolve) => {\r\n    let self = this;\r\n    let tabListHeight; // 获取tab高度\r\n    // 获取除去tabList高度，全屏高度（空态状态时需要）\r\n    wx.createSelectorQuery().select('#tab-list').fields({\r\n      size: true\r\n    }, function (res) {\r\n      tabListHeight = res.height\r\n      wx.getSystemInfo({\r\n        success: function(resp) {\r\n          self.windowHeight = resp.windowHeight - tabListHeight\r\n        }\r\n      })\r\n    }).exec()\r\n    // 获取单个item高度\r\n    wx.createSelectorQuery().select('#base-item').fields({\r\n      size: true\r\n    }, function (res) {\r\n      self.baseItemHeight = res.height\r\n      resolve()\r\n    }).exec()\r\n  })\r\n}复制代码如果频繁切换swiper会导致卡死，是因为触摸滑动swiper和点击选项卡时赋值swiperIndex都会触发swiper bindchange 事件，这里做了判断处理。// 滑动切换\r\nswiperTab (e) {\r\n  // 如果是触摸滑动切换\r\n  if (e.mp.detail.source === 'touch') {\r\n    if (this.currentTab === e.mp.detail.current) {\r\n      return false;\r\n    } else {\r\n      this.currentTab = e.mp.detail.current\r\n      this.isLoading = false\r\n      this.allLoaded = false\r\n      this.pageNum = 1\r\n      this.loadTips = '上拉加载更多'\r\n      this.getDataList(this.loadTips);\r\n    }\r\n  }\r\n},\r\n// 点击切换\r\nclickTab (tab) {\r\n  if (this.currentTab === tab) {\r\n    return false;\r\n  } else {\r\n    this.currentTab = tab\r\n    this.allLoaded = false\r\n    this.pageNum = 1\r\n    this.loadTips = '上拉加载更多'\r\n    this.getDataList(this.loadTips);\r\n  }\r\n},复制代码scroll-view封装indexList实现两种定位方式：点击定位，按住右侧字母indexList滑动定位。技术难点：按住右侧indexList滑动定位，获取字母indexList的上边距 offsetTop ，按住滑动时获取手指距离屏幕顶部的距离 clientY， 手指移动距离为 moveY=clientY-offsetTop， 具体实现如下：// 索引定位(滑动开始) @touchstart=\"handlerStart\"\r\nhandlerStart (e) {\r\n  this.targetIndex = e.mp.target.id\r\n},\r\n// 索引定位(滑动过程) @touchmove=\"handlerMove\"\r\nhandlerMove(e) {\r\n  let keyList = this.keyList;\r\n  // 手指滑动垂直距离\r\n  let moveY = e.mp.touches[0].clientY;\r\n  let rY = moveY - this.offsetTop;\r\n  if (rY >= 0) {\r\n    // apHeight为字母表indexList中单个字母块高度，计算结果向上取整\r\n    let index = Math.ceil((rY - this.apHeight) / this.apHeight);\r\n    if (index >= 0 && index < keyList.length) {\r\n      this.targetIndex = keyList[index];\r\n    }\r\n  } else {\r\n    this.targetIndex = keyList[0]\r\n  }\r\n},复制代码坑view或者text设置border-radius=50%有时候在真机会变形（排除flex布局的影响）。wxml不支持复杂逻辑，如模版字符串，字符串截取等等。text设置行高的时候会出现样式异常，替换成view便可解决此问题。wx.showLoading和wx.showToast的属性title不可为空，线上会报错，影响js执行。总结本文只是简单讲一下项目中涉及到的几处技术要点，欢迎交流。打一波广告："}
{"title": "微信小程序集成 Jenkins ", "author": "Rolan", "pub_time": "2018-9-4 00:18", "article_content": "微信小程序的测试发布在没有 CI/CD 等相关工具的情况下，存在着如下的问题：小程序开发助手中，同一个开发者只能显示一个开发版本测试同事找开发要二维码，效率较低本地生成的二维码会出现携带本地代码、未及时拉取分支其他改动等问题为了避免如上问题的发生，采用 微信小程序集成 Jenkins 的方案。基础在介绍实现方案之前，先来回顾一下常规的微信小程序发布流程。从上面的流程图可以看出，微信小程序预览、上传都是需要在微信开发者工具中进行的，接下来了解一下微信开发者工具提供的上传方式。微信开发者工具除了图形化界面，微信开发者工具还提供了命令行与 HTTP 服务两种接口供外部调用，来进行登录、预览、上传等操作。命令行调用命令行工具所在位置：macOS: <安装路径>/Contents/Resources/app.nw/bin/cliWindows: <安装路径>/cli.bat以 macOS 操作系统示例：1、打开开发者工具：/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\n复制代码其中， /Applications/wechatwebdevtools.app/ 为安装路径。2、登录：/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -l\r\n复制代码输入上面的命令行后，终端中打印出登录二维码，使用微信扫码登录。在微信端完成操作之后，会输出 login success ，如下图所示：如果想得到 base64 形式的二维码，可以使用下面的命令：# 登录，在终端中打印登录 base64 形式的二维码\r\ncli -l --login-qr-output base64\r\n\r\n# 登录，二维码转成 base64 并存到文件 /Users/username/code.txt \r\ncli -l --login-qr-output base64@/Users/username/code.txt\r\n复制代码更多 API 可以参考命令行调用 。HTTP 服务HTTP 服务在 工具启动后自动开启 ，每次开启 host 固定为 127.0.0.1，端口号并不固定。端口号在 用户目录 下记录，位置如下：macOS : ~/Library/Application Support/微信web开发者工具/Default/.ideWindows : ~/AppData/Local/微信web开发者工具/User Data/Default/.ide以 macOS 操作系统示例：首先需要 运行开发者工具 ，可以利用上面介绍的命令行方法打开微信开发者工具。/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\nport=$(cat \"/Users/zyy/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\n复制代码这样就可以拿到微信开发者工具运行的端口号了，其中， /Users/zyy/ 为用户目录。1、打开开发者工具：# 打开工具\r\nhttp://127.0.0.1:端口号/open\r\n# 打开/刷新项目\r\nhttp://127.0.0.1:端口号/open?projectpath=项目全路径\r\n复制代码2、登录：# 登录，返回图片格式的二维码\r\nhttp://127.0.0.1:端口号/login\r\n# 登录，取 base64 格式二维码\r\nhttp://127.0.0.1:端口号/login?format=base64\r\n# 登录，取 base64 格式二维码，并写入 /Users/username/logincode.txt\r\nhttp://127.0.0.1:端口号/login?format=base64&qroutput=%2FUsers%2Fusername%2Flogincode.txt\r\n复制代码3、预览：# 预览路径为 /Users/username/demo 的项目，返回图片格式的二维码\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo\r\n\r\n# 预览路径为 /Users/username/demo 的项目，返回 base64 格式的二维码\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&format=base64\r\n\r\n# 预览路径为 /Users/username/demo 的项目，返回 base64 格式的二维码，并写入 /Users/username/logincode.txt\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&format=base64&qroutput=%2FUsers%2Fusername%2Flogincode.txt\r\n\r\n# 预览路径为 /Users/username/demo 的项目，返回图片格式的二维码，并将预览信息输出至 /Users/username/info.json\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&infooutput=%2Users%2username%2info.json\r\n复制代码更多 API 可以参考HTTP 调用 。方案微信开发者工具目前只有 macOS 和 Windows 两种版本，这限制了服务器的系统。下面以 macOS 为例， 来介绍具体的实现过程：安装 JenkinsThe leading open source automation server, Jenkins provides hundreds of plugins to support building, deploying and automating any project.作为领先的开源自动化服务器，Jenkins提供数百个插件来支持构建，部署和自动化任何项目。Jenkins 依赖于 Java 运行环境，所以需要在机器上安装 Java。安装 Jenkins 方式很多，可以在官网直接下载最新的软件包，然后执行下面的命令启动 Jenkins 。java -jar jenkins.war --httpPort=8888\r\n复制代码其中， --httpPort=8888 为设置服务端口号，默认端口号为 8080 。新建任务选择 “ 构建一个自由风格的软件项目 ” ，在输入任务名称之后，点击确定按钮，进入到任务配置页面。任务配置在介绍任务配置之前，先来看一下最终要实现的功能。主要的功能点如下：使用 git 来管理代码，可以选择分支打包版本（开发版／体验版）可以选择（注意：这里的「开发版」对应「预览」，体验版对应「上传」）1、源码管理在任务配置页面的第二项 “源码管理” 中，选择 git 方式管理代码。填入 git 仓库地址及访问的账户，上图中的 $branch 是自定义的构建参数，下面来看一下构建参数的定义。2、构建参数在任务配置页面的第二项 “General” 中，选择 “参数化构建过程”，进入构建参数配置页面。参数有上述的几种类型供选择，可以参考下图进行配置，这里不再赘述。需要注意的是，这里的 name 可以通过 branch 。构建在任务配置页面的 “构建” 中，选择 “执行 shell” 方式来进行构建。Tips：这里的 shell 脚本是微信小程序集成 Jenkins 最核心的内容。回顾一下，本文最开始提到的微信小程序发布流程图：这一系列的操作使用 shell 脚本来完成，如何实现呢？登录微信开发者工具的登录需要在微信端扫码确认，这一步微信并没有提供账号密码的登录方式。不过，微信开发者工具是可以保持登录态的。由于微信限制，一个开发者身份只能在一个终端登录，所以我们申请了一个新的微信账号「前端小姐姐」用于在 Jenkins 机器上登录。项目基础设置在图形化界面中，上传代码时，会在开发者工具中填入 AppID 、项目路径等信息，也会在「详情」中选择项目的基本设置，比如「ES6 转 ES5」。微信还提供了一种配置方法，在项目根目录使用 project.config.json 文件。这里通过一段 node 脚本，生成 project.config.json 文件。const fs = require('fs')\r\n\r\nconst content = '{\"description\":\"项目配置文件。\",\"setting\":{\"urlCheck\":false,\"es6\":true,\"postcss\":true,\"minified\":true,\"newFeature\":true},\"miniprogramRoot\":\"./\",\"compileType\":\"miniprogram\",\"appid\":\"***\",\"projectname\":\"wechat-app\",\"condition\":{\"search\":{\"current\":-1,\"list\":[]},\"conversation\":{\"current\":-1,\"list\":[]},\"plugin\":{\"current\":-1,\"list\":[]},\"game\":{\"currentL\":-1,\"list\":[]},\"miniprogram\":{\"current\":-1,\"list\":[]}}}'\r\n\r\nfs.writeFileSync('./dist/project.config.json', content, 'utf-8')\r\n复制代码这样就完成了项目的基础设置，接下来将介绍如何通过 shell 脚本完成上传。shell 脚本echo -------------------------------------------------------\r\necho GIT_BRANCH: ${GIT_BRANCH}\r\necho -------------------------------------------------------\r\n# 执行项目构建\r\nnpm i --registry=http://registry.npm.taobao.org\r\nnpm run build\r\n# 打开微信开发者工具\r\n/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\nport=$(cat \"/Users/devops/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\nreturn_code=$(curl -sL -w %{http_code} http://127.0.0.1:${port}/open)\r\nif [ $return_code == 200 ]\r\n  then\r\n  echo \"返回状态码200，devtool启动成功！\"\r\nelse\r\n  echo \"返回状态码${return_code}，devtool启动失败\"\r\n  exit 1\r\nfi\r\nif [ \"$build_type\" == \"dev\" ]\r\n  then\r\n  echo \"发布开发版！\"\r\n  wget -O $BUILD_ID.png http://127.0.0.1:${port}/preview?projectpath=/Users/Shared/Jenkins/Home/workspace/fe-wechat-app/dist\r\n  echo \"预览成功！请扫描二维码进入开发版！\"\r\nelif [ \"$build_type\" == 'prod' ]\r\n  then\r\n  echo \"准备上传！\"\r\n  /Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -u 1.0.0@/Users/Shared/Jenkins/Home/workspace/fe-wechat-app/dist --upload-desc 'initial release'\r\n  echo \"上传成功！请到微信小程序后台设置体验版并提交审核！\"\r\nfi\r\n复制代码因为本项目需要编译代码，所以服务器上需要安装 node 和 npm。 npm run build 命令不光在编译代码，而且还执行了前面介绍的生成 project.config.json 的 node 脚本。开发版上传成功后，将二维码图片保存下来，用于构建后显示二维码和发送邮件。这里结合 命令行调用 和 HTTP 调用 两种方式来完成上传，主要出于以下原因：HTTP 调用 可以很方便的下载生成的二维码图片HTTP 服务 只有在微信开发者工具启动之后，才会启动，所以需要通过 命令行调用 方式，来启动微信开发者工具构建后使用 description setter plugin 插件来实现，构建完成后显示二维码图片。安装插件回到 Jenkins 主页，在「系统管理」中，进入到「插件管理」页面，搜索 description setter plugin 并安装。安装好插件后，返回任务配置页面。在「构建后操作」中，增加「Set build description」步骤，如下图：这里采用 HTML <img> 标签形式，展示二维码信息，如下：<img src=\"http://机器ip:端口/job/项目名称/ws/${BUILD_ID}.png\" alt=\"二维码${BUILD_ID}\" width=\"200\" height=\"200\" /> <a href=\"http://机器ip:端口/job/项目名称/ws/${BUILD_ID}.png\">二维码${BUILD_ID}</a>\r\n复制代码按照上面的方式配置后，发现图片并没有显示出来，而是显示了文本信息。这是由于 Jenkins 出于安全的限制，所有描述信息的 Markup Formatter 默认都采用 Plain text 的模式。在「系统管理」-> 「全局安全配置」中，将 Markup Formatter 由 Plain text (纯文本) 更改为 Safe HTML 即可。按照上面的步骤操作后，就可以显示出开发版二维码。因为 Jenkins 构建时，均使用「前端小姐姐」微信账号，所以小程序开发助手上「前端小姐姐」发布的开发版不确定是哪位同学构建的，故需要使用 Jenkins 平台生成的二维码，并注意二维码有效期（有效期25分钟）。总结本文以微信小程序常规的发布流程为切入点，循序渐进地介绍了如何集成 Jenkins 实现微信小程序预览、上传功能。后台、测试同事可以在该平台上选择分支获取开发版用于联调、测试，解决了本文开篇提及的问题。由于本文篇幅有限，只是介绍了该平台的一些基本功能，如果有其他的需求，可以参考文末的拓展链接解决。此外，文中若有任何表述不清或不当的地方，欢迎大家批评指正～本文首发于 github.com/yingye/Blog… ，欢迎各位关注我的Blog，正文以issue形式呈现，喜欢请点star，订阅请点watch～"}
{"title": "简陋至极：微信小程序日历组件（思路） ", "author": "Rolan", "pub_time": "2018-9-4 00:35", "article_content": "最近在做微信小程序项目，其中涉及到日历。一直以来，遇到日历，就是网上随便找个插件，这次心血来潮，想着自己去实现一下。这次不是封装功能强大，健硕完美的组件，只是记录一下，主体思路。更多功能还得根据项目需要，自己去挖掘、实现。（大佬轻喷）思路分析首先最主要的一点，就是要计算出某年某月有多少天，其中涉及到大小月，闰、平年二月。其次，弄清楚每月一号对应的是周几。然后，有时为填充完整，还需显示上月残余天数以及下月开始几天，这些又该如何展示。最后，根据自己项目需求实现其它细枝末节。计算每月天数按照一般思路，[1,3,5,7,8,10,12]这几个月是31天，[2,3,6,9,11]这几个月是30天，闰年2月29天，平年2月28天。每次需要计算天数时，都得如此判断一番。方案可行，而且也是大多数人的做法。但是，这个方法，我却觉得有些繁琐。其实换一种思路，也未尝不可。时间戳就是一个很好的载体。当前月一号零时的时间戳，与下一月一号零时的时间戳之差，不就是当前月天数的毫秒数嘛。// 获取某年某月总共多少天\r\ngetDateLen(year, month) { \r\n    let actualMonth = month - 1;\r\n    let timeDistance = +new Date(year, month) - +new Date(year, actualMonth);\r\n    return timeDistance / (1000 * 60 * 60 * 24);\r\n},\r\n复制代码看到上述代码，你可能会问，是不是还缺少当月为12月时的特殊判断，毕竟涉及到跨年问题。当然，你无需担心,根据MDN中关于Date的表述，js已经为我们考虑好了这一点当Date作为构造函数调用并传入多个参数时，如果数值大于合理范围时（如月份为13或者分钟数为70），相邻的数值会被调整。比如 new Date(2013, 13, 1)等于new Date(2014, 1, 1)，它们都表示日期2014-02-01（注意月份是从0开始的）。其他数值也是类似，new Date(2013, 2, 1, 0, 70)等于new Date(2013, 2, 1, 1, 10)，都表示时间2013-03-01T01:10:00。计算每月一号是周几呃，这个就不需要说了吧，getDay()你值得拥有// 获取某月1号是周几\r\ngetFirstDateWeek(year, month) { \r\n    return new Date(year, month - 1, 1).getDay()\r\n},\r\n复制代码每个月的数据如何展示如果只是简单展示当月数据，那还是很简单的，获取当月天数，依次遍历，就可以拿到当月所有数据。// 获取当月数据，返回数组\r\ngetCurrentArr(){ \r\n    let currentMonthDateLen = this.getDateLen(this.data.currentYear, this.data.currentMonth) // 获取当月天数\r\n    let currentMonthDateArr = [] // 定义空数组\r\n    if (currentMonthDateLen > 0) {\r\n        for (let i = 1; i <= currentMonthDateLen; i++) {\r\n\t    currentMonthDateArr.push({\r\n\t        month: 'current', // 只是为了增加标识，区分上下月\r\n                date: i\r\n            })\r\n        }\r\n    }\r\n    this.setData({\r\n    \tcurrentMonthDateLen\r\n    })\r\n    return currentMonthDateArr\r\n},\r\n复制代码很多时候，为了显示完整，需要显示上下月的残余数据。一般来说，日历展示时，最大是7 X 6 = 42位，为啥是42位，呃，自己去想想吧。当月天数已知，上月残余天数，我们可以用当月1号是周几来推断出来，下月残余天数，正好用42 - 当月天数 -上月残余。// 上月 年、月\r\npreMonth(year, month) { \r\n    if (month == 1) {\r\n\treturn {\r\n\t    year: --year,\r\n\t    month: 12\r\n\t}\r\n    } else {\r\n    \treturn {\r\n\t    year: year,\r\n\t    month: --month\r\n    \t}\r\n    }\r\n},\r\n复制代码// 获取当月中，上月多余数据，返回数组\r\ngetPreArr(){ \r\n    let preMonthDateLen = this.getFirstDateWeek(this.data.currentYear, this.data.currentMonth) // 当月1号是周几 == 上月残余天数）\r\n        let preMonthDateArr = [] // 定义空数组\r\n    if (preMonthDateLen > 0) {\r\n\tlet { year, month } = this.preMonth(this.data.currentYear, this.data.currentMonth) // 获取上月 年、月\r\n\tlet date = this.getDateLen(year, month) // 获取上月天数\r\n\tfor (let i = 0; i < preMonthDateLen; i++) {\r\n\t\tpreMonthDateArr.unshift({ // 尾部追加\r\n                        month: 'pre', // 只是为了增加标识，区分当、下月\r\n\t\t    date: date\r\n                })\r\n\t\tdate--\r\n\t}\r\n    }\r\n    this.setData({\r\n\tpreMonthDateLen\r\n    })\r\n    return preMonthDateArr\r\n},\r\n复制代码// 下月 年、月\r\nnextMonth(year, month) { \r\n    if (month == 12) {\r\n\treturn {\r\n\t    year: ++year,\r\n\t    month: 1\r\n\t}\r\n    } else {\r\n\treturn {\r\n            year: year,\r\n\t    month: ++month\r\n\t}\r\n    }\r\n},\r\n复制代码// 获取当月中，下月多余数据，返回数组\r\ngetNextArr() { \r\n    let nextMonthDateLen = 42 - this.data.preMonthDateLen - this.data.currentMonthDateLen // 下月多余天数\r\n    let nextMonthDateArr = [] // 定义空数组\r\n    if (nextMonthDateLen > 0) {\r\n        for (let i = 1; i <= nextMonthDateLen; i++) {\r\n            nextMonthDateArr.push({\r\n                month: 'next',// 只是为了增加标识，区分当、上月\r\n                date: i\r\n            })\r\n        }\r\n    }\r\n    return nextMonthDateArr\r\n},\r\n复制代码整合三组数据，就得到了完整的当月数据，格式如下[\r\n    {month: \"pre\", date: 30},\r\n    {month: \"pre\", date: 31},\r\n    {month: \"current\", date: 1},\r\n    {month: \"current\", date: 2},\r\n    ...\r\n    {month: \"current\", date: 31},\r\n    {month: \"next\", date: 1},\r\n    {month: \"next\", date: 2}\r\n]\r\n复制代码至于上下月切换，选择某年某月等功能，无非就是参数变化而已，自己琢磨琢磨即可。骨架都有了，你想创造什么样的功能还不是手到擒来。"}
{"title": "微信小程序 | 切换按钮或者view的选中状态 ", "author": "Rolan", "pub_time": "2018-9-4 00:42", "article_content": "实现非常简单，通过一个简单的判断当前data中的选中值，点击按钮时更新data值，重新渲染页面。index.wxml文件<view class=\"switch-type\">\r\n    <view class=\"btn {{currentSelectTripType == 'pinche' ? 'active' : ''}}\" bindtap='selectedPinche' data-id='pinche'>拼车</view>\r\n    <view class=\"btn {{currentSelectTripType == 'baoche' ? 'active' : ''}}\" bindtap='selectedBaoche' data-id='baoche'>包车</view>\r\n  </view>\r\nindex.js文件Page({\r\n  data: {~~~~\r\n    currentSelectTripType: 'pinche',\r\n  },\r\n  // 更新data 切换选中状态\r\n  selectedPinche: function (e) {\r\n    this.setData({\r\n      currentSelectTripType: e.currentTarget.dataset.id\r\n    })\r\n  },\r\n  selectedBaoche: function(e) {\r\n    this.setData({\r\n      currentSelectTripType: e.currentTarget.dataset.id\r\n    })\r\n  },\r\n})\r\n附上一个简单的样式index.wxss.switch-type {\r\n  display: flex;\r\n}\r\n.switch-type .btn:first-child {\r\n  border-top-right-radius: 0;\r\n  border-bottom-right-radius: 0;\r\n}\r\n.switch-type .btn:last-child {\r\n  border-top-left-radius: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n.switch-type .btn {\r\n  background: #dfdfdf;\r\n  padding: 10rpx 40rpx;\r\n}\r\n.switch-type .btn.active {\r\n  border: 2rpx solid #007bff;\r\n  background: #fff;\r\n}"}
{"title": "小程序远程图片资源按需预加载 ", "author": "Rolan", "pub_time": "2018-9-4 15:27", "article_content": "最近做H5开发遇到个问题，为了防止页面打开时，出现大图加载缓慢的情况，写了一个图片资源管理器，今天顺便实现了一下小程序版。特别说明一下，小程序由于资源包大小限制，很多图片资源会存放到CND图片服务器上，为了实现小程序初始化时按需加载远程图片资源，实现了以下加载器，希望能解决部分小程序新人开发者预加载图片的苦恼。特别强调：本加载器为初级版本，暂未研究其他实现方式，当前实现方式需要在微信公众平台->设置->downloadFile合法域名，中添加想要加载的图片所在服务器合法域名。原理介绍：使用小程序自带API读取远程图片资源：wx.getImageInfo({\r\n src: 'images/a.jpg',\r\n success: function (res) {\r\n console.log(res.width)\r\n console.log(res.height)\r\n }\r\n}) \r\n这个接口可以创建图片组件对象并返回图片加载状态。加载器用法：1、在app.js的同级目录下创建一个ImageSource.js作为图片资源的路径管理文件（可以根据情况改为其他文件名称）。2、在utils文件夹下放入ImageLoader.js或ImageLoader.min.js（附件）。3、根据需要在对应的文件中创建ImageLoader对象（看下文）。使用示例：1、载入文件：const ImageLoader = require('./utils/ImageLoader.min.js');\r\nconst ImageSource = require('./imageSource.js');\r\nImageLoader.min.js 为加载器源文件。imageSource.js 为图片资源路径文件。2、创建ImageLoader对象。new ImageLoader({\r\n base: ImageSource.BASE,\r\n source: [ImageSource],\r\n loading: res => {\r\n // 可以做进度条动画\r\n console.log(res);\r\n },\r\n loaded: res => {\r\n // 可以加载完毕动画\r\n console.log(res);\r\n }\r\n });\r\n参数base : String 图片资源的基础路径 必填 示例： \"https://image.example.com/static/images/\"source : Array 需要预加载的图片资源 必填 示例： [ImageSource.banners, ImageSource.imageList]loading : function 图片加载中的回调方法 非必填 示例：loaded : funciton 图片记载完成后的回调 非必填 示例:加载器（ImageLoader.js）源码：let base = 0;\r\nlet Img = function(src) {\r\n this.src = src;\r\n this.status = false;\r\n this.fail = false;\r\n}\r\n \r\nlet loop = (o, res) => {\r\n let tem = Object.keys(o);\r\n tem.map(v => {\r\n if (typeof o[v] === 'object') {\r\n loop(o[v], res);\r\n } else {\r\n if(v === 'BASE') {\r\n base = o[v];\r\n } else {\r\n res.push(o[v]);\r\n }\r\n }\r\n });\r\n}\r\n \r\nfunction ImageLoader(obj) {\r\n let arr = [];  if(obj.loading) {\r\n this.loadingcallback = obj.loading;\r\n }\r\n if(obj.loaded) {\r\n this.loadedcallback = obj.loaded;\r\n }\r\n \r\n if(obj.base) {\r\n base = obj.base\r\n }\r\n this.insert = (item) => {\r\n arr.push(item);\r\n };\r\n \r\n this.init = (o) => {\r\n let res = [];\r\n loop(o, res);\r\n console.log(res)\r\n res.map((v) => {\r\n this.insert(new Img(v));\r\n });\r\n this.load();\r\n };\r\n \r\n this.load = () => {\r\n this.start = (new Date).getTime();\r\n arr.map((v) => {\r\n let src = base ? base + v.src: v.src;\r\n wx.getImageInfo({\r\n src: src,\r\n success: res => {\r\n v.status = true;\r\n },\r\n fail: err => {\r\n v.fail = true;\r\n }\r\n })\r\n });\r\n let timer = setInterval(() => {\r\n let status = this.isLoaded();\r\n if (status) {\r\n clearTimeout(timer);\r\n }\r\n }, 200);\r\n \r\n setTimeout(() => {\r\n clearTimeout(timer);\r\n }, 60000);\r\n };\r\n \r\n this.isLoaded = () => {\r\n let status = true,\r\n count = 0,\r\n fail = 0;\r\n arr.map((v) => {\r\n if (!v.status) {\r\n status = false;\r\n } else {\r\n count += 1;\r\n }\r\n if(v.fail) {\r\n status = true;\r\n fail += 1;\r\n }\r\n });\r\n if(status) {\r\n if(this.loadedcallback) {\r\n this.loadedcallback({\r\n status: true,\r\n timecost: (new Date).getTime() - this.start,\r\n success: count,\r\n fail: fail,\r\n totalcount: arr.length\r\n })\r\n }\r\n } else {\r\n if(this.loadingcallback) {\r\n this.loadingcallback({\r\n status: false,\r\n percent: count / arr.length\r\n });\r\n }\r\n }\r\n return status;\r\n };\r\n if(obj.source) {\r\n this.init(obj.source);\r\n }\r\n}\r\nmodule.exports = ImageLoader\r\n图片资源路径文件（imageSource.js）源码：module.exports = {\r\n \"BASE\": \"https://img.caibeitv.com/static_project/teacherTest/static/img/\",\r\n \"single1\": \"ghost.4449aa4.png\",\r\n \"single2\": \"ghost.4449aa4.png\",\r\n \"single3\": \"ghost.4449aa4.png\",\r\n \"single4\": \"ghost.4449aa4.png\",\r\n \"pages\": {\r\n \"index\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"user\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"home\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"login\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"]\r\n },\r\n \"imageList\": [\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\"\r\n ],\r\n \"folders\": {\r\n \"page1\": \"ghost.4449aa4.png\",\r\n \"page2\": \"ghost.4449aa4.png\",\r\n \"inner\": [\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\"\r\n ],\r\n \"home\": {\r\n \"poster\": \"ghost.4449aa4.png\"\r\n }\r\n }\r\n}\r\n说明：BASE 字段必填 根据自我需要填写。其他图片资源支持：1、直接key：value形式把图片路径写入，如：\"single1\": \"ghost.4449aa4.png\" \r\n2、类似于pages目录把每个页面的远程资源写入到对应位置下，方便引用和管理，如：\"pages\": {\r\n \"index\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"user\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"home\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"],\r\n \"login\": [\"ghost.4449aa4.png\", \"ghost.4449aa4.png\"]\r\n },\r\n3、直接以数组方式把图片堆放在一个数组里，如：\"imageList\": [\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\"\r\n ] \r\n4、随意的资源数组，对象嵌套，如：\"folders\": {\r\n \"page1\": \"ghost.4449aa4.png\",\r\n \"page2\": \"ghost.4449aa4.png\",\r\n \"inner\": [\r\n \"ghost.4449aa4.png\",\r\n \"ghost.4449aa4.png\"\r\n ],\r\n \"home\": {\r\n \"poster\": \"ghost.4449aa4.png\"\r\n }\r\n }\r\n这样就完成了整个远程图片资源加载器的配置，可以在new ImageLoader() 对象的 loading, loaded回调中看到图片预加载的最终状态status，数量totalcount，成功加载的图片数量success，加载失败的图片数量fail, 加载图片的总计耗时timecost（单位ms）。创建ImageLoader对象时source字段的说明：new ImageLoader({\r\nbase: ImageSource.BASE,\r\nsource: [ImageSource],\r\nloading: res => {\r\n// 可以做进度条动画\r\nconsole.log(res);\r\n},\r\nloaded: res => {\r\n// 可以加载完毕动画\r\nconsole.log(res);\r\n}\r\n});\r\nsource字段接受一个Array类型的参数，以上文中imageSource.js中的配置来说，写了很多不同格式的数据，使用const ImageSource = require('./imageSource.js');\r\n引入后，可以直接使用ImageSource来读取各个部分的数据，因此在配置source字段时可以直接把整个ImageSource对象放入进去source: [ImageSource]\r\n也可以根据项目需要只加载其中一部分资源，如：source: [ImageSource.imageList, ImageSource.single2]\r\n这样加载器在执行时就会只载入source中写入的部分，而不是整个ImageSource。最后，在加载过程中如果过于耗时，可以选择在每个页面的onLoad里单独加载资源，做法类似于在app里调用，本文的示例是写在app.js的onLaunch中。如果加载时间过长可以做一个进度条或者加载动画，优化启动体验。预加载过的图片会在微信内存中缓存一到小程序进程被关闭，因此在随后的页面里可以直接使用图片。const app = getApp();\r\nconst imgSource = require('../../imageSource.js');\r\nPage({\r\n data: {\r\n base: imgSource.BASE,\r\n src: imgSource.single1\r\n },\r\n onLoad: function () {\r\n console.log(imgSource)\r\n }\r\n})\r\n页面上的Image会立即显示，不需要重新发起加载图片请求。个人研究结果，如有错误、不足欢迎批评指正，相互探讨。个人QQ: 837195936 熊专栏作家熊晨沣（个人QQ: 83719593）。小程序社区博主，坚持原创分享技术博文。本文原创发布于小程序社区。未经许可，禁止转载原文地址：小程序远程图片资源按需预加载-小程序社区/博主专区-微信小程序开发社区-微信小程序联盟"}
{"title": "实现一个扫描商品条码进行评价或留言的小程序（附源码） ", "author": "Rolan", "pub_time": "2018-9-5 00:08", "article_content": "对准上面的小程序码，扫一下，‘嘀’~地一声，扫码成功，打开小程序，进入小程序首页。因为手头上没有可乐，所以我找来了一只非常专业的猫，扮演一瓶330ml的可口可乐演示给大家看。摁住它，对准它的条码，扫一下，‘喵’~地一声，说明猫跑掉了，扫码失败了，去追如果‘嘀’~地一声，说明扫码成功了，这时页面就自动跳到商品详情页。然后你就可以看得到别人在可口可乐下写的留言，当然你也可以点击右下角的蓝色按钮就发表你的留言了；原理：因为一个商品对应唯一一个条码，所以扫描同一个商品条码就可以进入唯一一个留言列表；全国各地的可口可乐330ml的条形码都是一样的，扫码后都会进入同一个页面条形码就像一个暗号，一句口令，一个邮差.. 当然，不只是条形码，二维码也可以留言，比如说别人的微信二维码一般是长时间不会变的，你可以码上说别人坏话。接下来详细介绍一下每个页面的功能2.首页首页有三个部分：1.用户的信息：头像和昵称；2.轮播图-可以放一些平时要展示的图片；3.扫码按钮-点击即可打开扫描条码；当用户点击扫码按钮时，我们就调用小程序的扫码接口去扫描商品条码，当用户扫描好条码后，我们就得到了商品条码（barcode）；这时，我们就可以跳转到商品详情页面了，顺便把条码传过去，这样商品详情页才能知道用户扫的是什么商品：wx.navigateTo({\r\n          url: \"/page/component/proDtl/proDtl?barcode=\" + barcode,  //把商品条码传给商品详情页\r\n    })\r\n复制代码3.商品详情页进入详情页后，我们的第一件事情：在生命周期onLoad中获取首页传过来商品条码，然后根据条码请求当前商品的留言列表，如果这个商品还没有人扫过的话，就可能没有留言，那我们只要显示“暂无留言”即可onLoad(options){\r\n       var barcode = options.barcode ? options.barcode:'';\r\n       this.getProductInfo(barcode)  //根据条码请求当前商品的留言列表\r\n  },\r\n复制代码在getProductInfo（）方法中，我们会向后台请求商品留言列表； 接着我们就把请求到的商品留言列表渲染到页面上:如果用户觉得请求到的商品名称是不对的，还可以点击名称进行编辑：最后，页面底部还有一个提交留言的小按钮：如果你要发表留言，你可以用你的食指点击它：点击按钮后，小程序就会跳到添加留言页面，顺便把商品条码信息传过去：turnToSubmit(){\r\n    wx.navigateTo({\r\n      url: \"/page/component/addNode/addNode?barcode=\" + this.data.barcode,\r\n    })\r\n  },\r\n复制代码4.添加留言页面如图，这时候我们就可以开始写我们的留言了。写完留言之后，你可以标注一下你的留言类型：如果你觉得你写的是一首诗，你可以选择类型为‘诗一首’；如果你觉得你写的是一封信，等待别人扫码阅读，你可以选择类型为‘鱼书’；如果你扫描的是一本书的条码，你可以选择类型为‘书摘’；类型的右边就是是上传图片功能，首先，我们点击'添加图片'小图标，这时就会使用小程序选择图片的接口打开相册或者直接拍照，得到图片之后，因为现在的手机图片拍照像素都比较高，导致图片比较大，上传会很慢，占服务器空间，请求也会很慢...所以为了优化用户体验，我们需要压缩一下图片然后再上传。wx.chooseImage({\r\n      count: 1, // 默认9  \r\n      sizeType: ['original'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: function (res) {  //图片选择成功之后\r\n        \r\n               var tempFilePaths = res.tempFilePaths;\r\n               self.compressedImg(res)  //调用compressedImg方法，先把图片压缩一下\r\n\r\n        }\r\n  })\r\n复制代码虽然小程序的选择图片接口可以设置默认压缩，但好像没什么用，还是需要找其他的方法压缩一下， 网上最普遍的图片压缩是使用了小程序提供的canvas画布，把用户上传的图片搞到画布上（....），然后根据画布上的图片高和宽判断图片是否过大，如果过大，就直接把画布按比例缩小：while (canvasWidth > 220 || canvasHeight > 220) {  //如果宽度或者高度大于220，我就认为图片要进一步压缩，你可以根据需求改成其他的数字\r\n          //比例取整\r\n      canvasWidth = Math.trunc(res.width / ratio)\r\n      canvasHeight = Math.trunc(res.height / ratio)\r\n      ratio++;\r\n   }\r\n复制代码图片的压缩参考自：[微信小程序：利用canvas缩小图片][ blog.csdn.net/akony/artic… ]然后把canvas上这张压缩了的图片上传到后台服务器：......\r\n   wx.uploadFile({  //上传图片\r\n          url: 'https://mp.orancat.com/proImgUpload',\r\n          filePath: photo.tempFilePath,  //压缩后的图片\r\n          name: 'file',\r\n          header: {\r\n            'content-type': 'multipart/form-data'\r\n          },\r\n          success: function (res) {\r\n    .......          \r\n\r\n复制代码图片上传成功之后，后台会返回上传图片的地址给我们，我们把图片渲染到页面上，用户就会知道图片上传成功了；最后点击'提交'按钮，就会把以下内容发送给后台，后台就会自动将留言保存到数据库；var data={\r\n      authorName: userName, //用户昵称\r\n      token: userId,  //用户ID\r\n      content: this.data.textContent, //留言文本内容\r\n      imgUrl: userImg,  //用户的头像\r\n      code: this.data.barcode,  //商品的条码\r\n      typeIndex: this.data.typeIndex, //留言的类型\r\n      nodeImgUrl: this.data.nodeImgUrl //用户上传的图片的地址\r\n    }\r\n复制代码留言提交成功之后，页面会自动切回商品详情页面，这时，你就可以看到自己刚刚的留言了；5.排行榜页面有过留言的商品都会出现在排行榜页面，并且按照留言的数量多少进行排列，点击单个商品就查看该商品下的留言；6.其他实现的功能1.分页在商品详情页，有可能出现这种情况，比如说假设A商品有120条留言，如果一进A商品详情页就要加载120条留言的话，可能页面加载半天都没有出来；这样的话用户体验就会非常不好。所以相对理想的方式应该是，假设12条留言为一页，那么A商品的留言总共有10页，当我们进入A商品的详情页面时，先加载第一页（前12条留言），当我们往上滑动页面到底部时就自动加载下一页的内容，一页一页按需加载；我们使用小程序提供的OnReachBottom触底事件实现分页加载，当用户滑动留言列表到底部时触发加载下一页：onReachBottom: function () { //滑动到底部时触发\r\n       this.setData({\r\n           bottomLoading: true  // 显示loading提示\r\n       })\r\n       this.getRankList()  //请求下一页数据\r\n  }\r\n复制代码同理，排行榜页面也使用了分页加载；2.通过wx.login获取用户唯一凭证openId由于用户的昵称，头像什么的都可能随时会改变，当openID不会变，所以使用openId作为用户唯一凭证；虽然我获取了用户的Id，但暂时还没有使用到；如果以后要弄个用户个人主页或者留言回复等等可能就要用到openId；3.gif图片上传如上所述，在图片上传前，我们把图片压缩了一下 如果图片是jpeg，png时没问题的 但如果图片时gif动图的话，那可能会导致动图不会动了（可能直接变成jpeg图片？） 所以我另外加了一个判断：如果图片时gif格式的话，就不压缩图片,直接上传：if(res.type=='gif'){\r\n       if(res.width>666||res.height>666){ //如果图片太大了，拒绝上传\r\n         wx.hideLoading()\r\n         wx.showModal({\r\n           title: '提示',\r\n           content: '动图太大了，请上传小一点的',\r\n           showCancel: false\r\n         })\r\n         return false;\r\n       }\r\n       res.tempFilePath=res.path;\r\n       _this.uploadImg(res)  //上传图片\r\n       return false;\r\n    }\r\n复制代码这样在window和安卓下就可以上传gif图片了。苹果手机呢？？咳咳..苹果手机一打开相册选动图，动图就自动变成了jpeg的不动图...所以苹果手机暂时上传不了动图，似乎没有解决办法。。7.下载与本地电脑运行在本文底部的github地址下载源码，用微信开发者工具，填上你的小程序appId，打开项目即可；记得在开发者工具点击‘’详情‘’设置不校验域名：如果你要提交审核并分布小程序的话，你需要在公众号平台上的\"设置>开发设置\"页面上设置小程序的服务器域名如下：然后，由于一般电脑没有摄像头不能扫码，所以当你需要扫码时，你可以把下面这张条码图片保存在本地电脑上，点击扫码按钮时打开这张图片即可：当然，你也可以自己找其他的条码；另外，需要注意的是，当你在本地电脑调试时，由于我们都是使用同一个后台接口，所以你发的留言都会同步到我的小程序上，所以尽量不要发送太明显的测试留言，例如：可以发一些强颜欢笑，积极向上，人畜无害的留言，例如："}
{"title": "Web直播，你需要先知道这些 ", "author": "Rolan", "pub_time": "2018-9-5 00:12", "article_content": "转自IMWeb社区，作者：Terrance，原文链接一、直播知识小科普一个典型的直播流程：录制->编码->网络传输（推流->服务器处理->CDN分发）->解码->播放IPB：一种常用的视频压缩方案，用I帧表示关键帧，B帧表示前向差别帧，P帧表示双向差别帧GOP (Group of Pictures)：GOP 越长（I帧之间的间隔越大），B 帧所占比例越高，编码的率失真性能越高。虽然B帧压缩率高，但解码时CPU压力会更大。音视频直播质量好坏的主要指标： 内容延时 、 卡顿（流畅度） 、 首帧时长音视频直播需要克服的主要问题：网络环境、多人连麦、主辅路、浏览器兼容性、CDN支持等MSE (Media Source Extensions)：W3C 标准API，解决 HTML5 的流问题（HTML5 原生仅支持播放 mp4/webm 非流格式，不支持 FLV），允许JavaScript动态构建 <video> 和 <audio>的媒体流。可以用MediaSource.isTypeSupported() 判断是否支持某种MINE类型。在ios Safari中不支持。文件格式/封装格式/容器格式 ：一种承载视频的格式，比如flv、avi、mpg、vob、mov、mp4等。而视频是用什么方式进行编解码的，则与Codec相关。举个栗子，MP4格式根据编解码的不同，又分为nMP4、fMP4。nMP4是由嵌套的Boxes 组成，fMP4格式则是由一系列的片段组成，因此只有后者不需要加载整个文件进行播放。Codec ：多媒体数字信号编码解码器，能够对音视频进行压缩（CO）与解压缩( DEC ) 。CODEC技术能有效减少数字存储占用的空间，在计算机系统中，使用硬件完成CODEC可以节省CPU的资源，提高系统的运行效率。常用视频编码 ：MPEG、H264、RealVideo、WMV、QuickTime。。。常用音频编码 ：PCM、WAV、OGG、APE、AAC、MP3、Vorbis、Opus。。。二、现有方案比较RTMP协议基于TCPadobe垄断，国内支持度高浏览器端依赖Flash进行播放2~5秒的延迟RTP协议Real-time Transport Protocol，IETF于1996提出的一个标准基于UDP实时性强用于视频监控、视频会议、IP电话CDN厂商、浏览器不支持HLS 协议Http Live Streaming，苹果提出的基于HTTP的流媒体传输协议HTML5直接支持(video)，适合APP直播，PC断只有Safari、Edge支持必须是H264+AAC编码因为传输的是切割后的音视频片段，导致内容延时较大flv.jsBilibli开源，解析flv数据，通过MSE封装成fMP4喂给video标签编码为H264+AAC使用HTTP的流式IO(fetch或stream)或WebSocket协议流式的传输媒体内容2~5秒的延迟，首帧比RTMP更快WebRTC协议1、Google力推，已成为W3C标准2、现代浏览器支持趋势，X5也支持（微信、QQ）3、基于UDP，低延迟，弱网抗性强，比flv.js更有优势4、支持Web上行能力5、编码为H264+OPUS6、提供NAT穿透技术（ICE）实际情况下，当用户数量很大时，对推流设备的性能要求很高，复杂的权限管理也难以实现，采用P2P的架构基本不可行。对于个别用户提供上行流、海量用户只进行拉流的场景，腾讯课堂实现了一种P2S的解决方案。 进一步学习可阅读jaychen的系列文章《WebRTC直播技术》。三、小程序+直播技术方案基于RTMP，官方说底层使用HTTP/2的一种内部传输机制，但又说是基于UDP的，这就搞不懂了。。。live-pusher 和 live-player 没有限制第三方云服务可直接使用腾讯云视频直播能力，只需配置好推流url、播放url即可推流url：播放url：下面是我根据官网教程搭建的一个音视频小程序，搭建过程简单，同一个局域网下直播体验也很流畅（读者也可直接搜索 腾讯视频云 小程序进行体验）：前端核心代码还是相当简洁的：live-pusher组件：设置好url推流地址（仅支持 flv, rtmp 格式）等参数即可，使用bindstatechange获取播放状态变化<view id='video-box'>  \r\n    <live-pusher\r\n          id=\"pusher\"\r\n          mode=\"RTC\"\r\n          url=\"{{pusher.push_url}}\" \r\n          autopush='true'\r\n          bindstatechange=\"onPush\">\r\n    </live-pusher>  \r\n </view>\r\n复制代码live-player组件：设置后src音视频地址（仅支持 flv, rtmp 格式）等参数即可，使用bindstatechange获取播放状态变化<view id='video-box'>  \r\n    <live-player\r\n        wx:for=\"{{player}}\"\r\n        id=\"player_{{index}}\"\r\n        mode=\"RTC\"\r\n        object-fit=\"fillCrop\"\r\n        src=\"{{item.playUrl}}\" \r\n        autoplay='true'\r\n        bindstatechange=\"onPlay\">\r\n   </live-player>\r\n </view>\r\n复制代码能否和WebRTC同时使用?对于腾讯课堂的应用场景，老师上课推流采用的是RTMP协议，考虑到WebRTC目前只能用于PC端拉流，那么在移动端能否让用户可以直接通过小程序来观看直播课呢？我觉得在技术层面可行的，接入小程序直播对于扩大平台影响力、社交圈分享、提高收费转化都会产生很大的帮助。难点在于复杂的权限控制、多路音视频流、多人连麦等问题，比如权限控制只能单独放到房间控制逻辑中完成，而音视频流本身缺乏这种校验；主辅路的切换还需要添加单独的信令控制，同时在小程序中加入相应的判断逻辑。"}
{"title": "微信小程序接入百度统计 ", "author": "Rolan", "pub_time": "2018-9-5 00:28", "article_content": "一. 百度统计添加应用，获取appkey和微信小程序统计sdk:百度统计首页，点击“我的全部应用”右侧的添加按钮：“应用类型”选择小程序统计，选择微信小程序，填写应用名称信息，选择内容分类，然后点击创建应用：获取到AppKey,下载微信小程序统计SDK，然后就可以在小程序中接入统计了，在这个页面下边就有SDK接入说明了。二. 微信小程序接入：把下载的微信小程序统计SDK解压后的mtj-wx-sdk.js和mtj-wx-sdk.config.js复制到小程序项目的utils文件夹中去：打开mtj-wx-sdk.config.js文件，将上边复制的appkey填写进去：编辑app.js,最顶部添加以下代码：const mtjwxsdk = require('./utils/mtj-wx-sdk.js');登录微信公众平台，进入小程序的设置->开发设置->服务器域名，把https://hmma.baidu.com加入request合法域名：三. 微信开发者工具中刷新项目配置：首次配置百度统计SDK，微信开发工具可能会报以下错误：如果已经在微信公众平台中把https://hmma.baidu.com加入request合法域名，那么就要刷新下开发工具的项目配置，如图,点下工具栏最右侧的“详情”，在详情弹窗界面中点击下“域名信息”，然后开发者工具就会自动刷新配置的，等https://hmma.baidu.com的域名刷新出来，就可以重新编译项目了："}
{"title": "小程序tab点击监听方法：onTabItemTap() ", "author": "Rolan", "pub_time": "2018-9-5 00:37", "article_content": "page()的详细生命周期，可以查看文档，今天主要说下其onTabItemTap()方法，很少用到，但我们在开发中为了解决一些问题（在此方法中触发登录界面），试用下此方法：方法说明Triggered when the user taps the tab if the current page is a tab page（当点击tab界面时触发）测试代码：  /** tab点击 */  onTabItemTap(item) {    console.log(item)    wx.showToast({      title: 'tab点击',    })  },  /**   * 生命周期函数--监听页面显示   */  onShow: function() {    self = this;    app.NetUtil.CheckLoginStatus(null, function(loginStatus) {});    ···分别在模拟器、iOS系统、Android系统分别测试，结果如下：效果图小程序模拟器：三个tab切换时，不会触发onTabItemTap()方法，如果已经在“个人中心”界面，再次点击tab，会触发该方法，而且点击几次，触发几次，没有APP的tab那么好使。iOS版微信的小程序：切换正常触发，多次点击可以根据自己的需要做相应处理。Android版微信（OPPO）的小程序：切换正常触发，多次点击可以根据自己的需要做相应处理。作者：恩来客 链接：https://www.jianshu.com/p/2e8370b7c760"}
{"title": "近两万字小程序攻略发布了 ", "author": "Rolan", "pub_time": "2018-9-6 00:21", "article_content": "该内容由银科控股融汇研发部曹俊及其团队授权提供。该团队拥有 10 多名小程序开发，深耕小程序领域，总结出了本篇优质长文。同时本篇内容也已经合并入我的 开源项目 中，目前项目内容包含了 JS、网络、浏览器相关、性能优化、安全、框架、Git、数据结构、算法等内容，无论是基础还是进阶，亦或是源码解读，你都能在本图谱中得到满意的答案，希望这个面试图谱能够帮助到大家更好的准备面试。小程序-登录unionid和openid了解小程序登陆之前，我们写了解下小程序/公众号登录涉及到两个最关键的用户标识：OpenId\r\nUnionId\r\n关键Apiwx.login 官方提供的登录能力wx.checkSession 校验用户当前的session_key是否有效wx.authorize 提前向用户发起授权请求wx.getUserInfo 获取用户基本信息登录流程设计以下从笔者接触过的几种登录流程来做阐述:利用现有登录体系直接复用现有系统的登录体系，只需要在小程序端设计用户名，密码/验证码输入页面，便可以简便的实现登录，只需要保持良好的用户体验即可。利用OpenId 创建用户体系:point_up_2:提过， OpenId 是一个小程序对于一个用户的标识，利用这一点我们可以轻松的实现一套基于小程序的用户体系，值得一提的是这种用户体系对用户的打扰最低，可以实现静默登录。具体步骤如下：小程序客户端通过 wx.login 获取 code传递 code 向服务端，服务端拿到 code 调用微信登录凭证校验接口，微信服务器返回 openid和会话密钥 session_key ，此时开发者服务端便可以利用 openid 生成用户入库，再向小程序客户端返回自定义登录态小程序客户端缓存 （通过 storage ）自定义登录态（token），后续调用接口时携带该登录态作为用户身份标识即可利用 Unionid 创建用户体系如果想实现多个小程序，公众号，已有登录系统的数据互通，可以通过获取到用户 unionid 的方式建立用户体系。因为 unionid 在同一开放平台下的所所有应用都是相同的，通过 unionid 建立的用户体系即可实现全平台数据的互通，更方便的接入原有的功能，那如何获取 unionid 呢，有以下两种方式：如果户关注了某个相同主体公众号，或曾经在某个相同主体App、公众号上进行过微信登录授权，通过 wx.login 可以直接获取 到 unionid结合 wx.getUserInfo 和 <button open-type=\"getUserInfo\"><button/> 这两种方式引导用户主动授权，主动授权后通过返回的信息和服务端交互 (这里有一步需要服务端解密数据的过程，很简单，微信提供了示例代码) 即可拿到 unionid 建立用户体系， 然后由服务端返回登录态，本地记录即可实现登录，附上微信提供的最佳实践：调用 wx.login 获取 code，然后从微信后端换取到 session_key，用于解密 getUserInfo返回的敏感数据。使用 wx.getSetting 获取用户的授权情况如果用户已经授权，直接调用 API wx.getUserInfo 获取用户最新的信息；用户未授权，在界面中显示一个按钮提示用户登入，当用户点击并授权后就获取到用户的最新信息。获取到用户数据后可以进行展示或者发送给自己的后端。注意事项需要获取 unionid 形式的登录体系，在以前（18年4月之前）是通过以下这种方式来实现，但后续微信做了调整（因为一进入小程序，主动弹起各种授权弹窗的这种形式，比较容易导致用户流失），调整为必须使用按钮引导用户主动授权的方式，这次调整对开发者影响较大，开发者需要注意遵守微信的规则，并及时和业务方沟通业务形式，不要存在侥幸心理，以防造成小程序不过审等情况。wx.login(获取code) ===> wx.getUserInfo(用户授权) ===> 获取 unionid\r\n复制代码因为小程序不存在 cookie 的概念， 登录态必须缓存在本地，因此强烈建议为登录态设置过期时间值得一提的是如果需要支持风控安全校验，多平台登录等功能，可能需要加入一些公共参数，例如platform，channel，deviceParam等参数。在和服务端确定方案时，作为前端同学应该及时提出这些合理的建议，设计合理的系统。openid ， unionid 不要在接口中明文传输，这是一种危险的行为，同时也很不专业。小程序-图片导出经常开发和使用小程序的同学对这个功能一定不陌生，这是一种常见的引流方式，一般同时会在图片中附加一个小程序二维码。基本原理借助 canvas 元素，将需要导出的样式首先在 canvas 画布上绘制出来 （api基本和h5保持一致，但有轻微差异，使用时注意即可）借助微信提供的 canvasToTempFilePath 导出图片，最后再使用 saveImageToPhotosAlbum（需要授权）保存图片到本地如何优雅实现根据上述的原理来看，实现是很简单的，只不过就是设计稿的提取，绘制即可，但是作为一个常用功能，每次都这样写一坨代码岂不是非常的难受。那小程序如何设计一个通用的方法来帮助我们导出图片呢？思路如下：绘制出需要的样式这一步是省略不掉的。但是我们可以封装一个绘制库，包含常见图形的绘制，例如矩形，圆角矩形，圆， 扇形， 三角形， 文字，图片减少绘制代码，只需要提炼出样式信息，便可以轻松的绘制，最后导出图片存入相册。笔者觉得以下这种方式绘制更为优雅清晰一些，其实也可以使用加入一个type参数来指定绘制类型，传入的一个是样式数组，实现绘制。结合上一步的实现，如果对于同一类型的卡片有多次导出需求的场景，也可以使用自定义组件的方式，封装同一类型的卡片为一个通用组件，在需要导出图片功能的地方，引入该组件即可。class CanvasKit {\r\n    constructor() {\r\n    }\r\n    drawImg(option = {}) {\r\n      ...\r\n      return this\r\n    }\r\n    drawRect(option = {}) {\r\n      return this\r\n    }\r\n    drawText(option = {}) {\r\n      ...\r\n      return this\r\n    }\r\n    static exportImg(option = {}) {\r\n      ...\r\n    }\r\n  }\r\n\r\n  let drawer = new CanvasKit('canvasId').drawImg(styleObj1).drawText(styleObj2)\r\n  drawer.exportImg()\r\n\r\n复制代码注意事项小程序中无法绘制网络图片到canvas上，需要通过downLoadFile 先下载图片到本地临时文件才可以绘制通常需要绘制二维码到导出的图片上，有一种方式导出二维码时，需要携带的参数必须做编码，而且有具体的长度（32可见字符）限制，可以借助服务端生成 短链接 的方式来解决小程序-数据统计数据统计作为目前一种常用的分析用户行为的方式，小程序端也是必不可少的。小程序采取的曝光，点击数据埋点其实和h5原理是一样的。但是埋点作为一个和业务逻辑不相关的需求，我们如果在每一个点击事件，每一个生命周期加入各种埋点代码，则会干扰正常的业务逻辑，和使代码变的臃肿，笔者提供以下几种思路来解决数据埋点：设计一个埋点sdk小程序的代码结构是，每一个 Page 中都有一个 Page 方法，接受一个包含生命周期函数，数据的 业务逻辑对象 包装这层数据，借助小程序的底层逻辑实现页面的业务逻辑。通过这个我们可以想到思路，对Page进行一次包装，篡改它的生命周期和点击事件，混入埋点代码，不干扰业务逻辑，只要做一些简单的配置即可埋点，简单的代码实现如下：代码仅供理解思路\r\n  page = function(params) {\r\n    let keys = params.keys()\r\n    keys.forEach(v => {\r\n        if (v === 'onLoad') {\r\n          params[v] = function(options) {\r\n            stat()   //曝光埋点代码\r\n            params[v].call(this, options)\r\n          }\r\n        }\r\n        else if (v.includes('click')) {\r\n          params[v] = funciton(event) { \r\n            let data = event.dataset.config\r\n            stat(data)  // 点击埋点\r\n            param[v].call(this)\r\n          }\r\n        }\r\n    })\r\n  }\r\n复制代码这种思路不光适用于埋点，也可以用来作全局异常处理，请求的统一处理等场景。分析接口对于特殊的一些业务，我们可以采取 接口埋点 ，什么叫接口埋点呢？很多情况下，我们有的api并不是多处调用的，只会在某一个特定的页面调用，通过这个思路我们可以分析出，该接口被请求，则这个行为被触发了，则完全可以通过服务端日志得出埋点数据，但是这种方式局限性较大，而且属于分析结果得出过程，可能存在误差，但可以作为一种思路了解一下。微信本身提供的数据分析能力，微信本身提供了常规分析和自定义分析两种数据分析方式，在小程序后台配置即可。借助 小程序数据助手 这款小程序可以很方便的查看。小程序-工程化工程化做什么目前的前端开发过程，工程化是必不可少的一环，那小程序工程化都需要做些什么呢，先看下目前小程序开发当中存在哪些问题需要解决：不支持 css预编译器,作为一种主流的 css解决方案，不论是 less,sass,stylus 都可以提升css效率不支持引入npm包 （这一条，从微信公开课中听闻，微信准备支持）不支持ES7等后续的js特性，好用的async await等特性都无法使用不支持引入外部字体文件，只支持base64没有 eslint 等代码检查工具方案选型对于目前常用的工程化方案，webpack，rollup，parcel等来看，都常用与单页应用的打包和处理，而小程序天生是 “多页应用” 并且存在一些特定的配置。根据要解决的问题来看，无非是文件的编译，修改，拷贝这些处理，对于这些需求，我们想到基于流的 gulp 非常的适合处理，并且相对于webpack配置多页应用更加简单。所以小程序工程化方案推荐使用 gulp具体开发思路通过 gulp 的 task 实现：实时编译 less 文件至相应目录引入支持async，await的运行时文件编译字体文件为base64 并生成相应css文件，方便使用依赖分析哪些地方引用了npm包，将npm包打成一个文件，拷贝至相应目录检查代码规范上述实现起来其实并不是很难，但是这样的话就是一份纯粹的 gulp 构建脚本和 约定好的目录而已，每次都有一个新的小程序都来拷贝这份脚本来处理吗？显然不合适，那如何真正的实现 小程序工程化 呢？ 我们可能需要一个简单的脚手架，脚手架需要支持的功能：支持新建项目，创建Page，创建Component支持内置构建脚本支持发布小程序，也可以想办法接入Jenkins等工具做持续集成 (小程序持续集成后面会提) ...小程序架构微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View 层用来渲染页面结构，AppService 层用来逻辑处理、数据请求、接口调用。它们在 两个线程里 运行。它们在 两个线程里 运行。它们在 两个线程里 运行。视图层和逻辑层通过系统层的 JSBridage 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。补充视图层使用 WebView 渲染，iOS 中使用自带 WKWebView，在 Android 使用腾讯的 x5 内核（基于 Blink）运行。逻辑层使用在 iOS 中使用自带的 JSCore 运行，在 Android 中使用腾讯的 x5 内核（基于 Blink）运行。开发工具使用 nw.js 同时提供了视图层和逻辑层的运行环境。在 Mac下 使用 js-beautify 对微信开发工具 @v1.02.1808080代码批量格式化：cd /Applications/wechatwebdevtools.app/Contents/Resources/package.nw\r\nfind . -type f -name '*.js' -not -path \"./node_modules/*\" -not -path -exec js-beautify -r -s 2 -p -f '{}' \\;\r\n复制代码在 js/extensions/appservice/index.js 中找到：267: function(a, b, c) {\r\n    const d = c(8),\r\n      e = c(227),\r\n      f = c(226),\r\n      g = c(228),\r\n      h = c(229),\r\n      i = c(230);\r\n    var j = window.__global.navigator.userAgent,\r\n      k = -1 !== j.indexOf('game');\r\n    k || i(), window.__global.getNewWeixinJSBridge = (a) => {\r\n      const {\r\n        invoke: b\r\n      } = f(a), {\r\n        publish: c\r\n      } = g(a), {\r\n        subscribe: d,\r\n        triggerSubscribeEvent: i\r\n      } = h(a), {\r\n        on: j,\r\n        triggerOnEvent: k\r\n      } = e(a);\r\n      return {\r\n        invoke: b,\r\n        publish: c,\r\n        subscribe: d,\r\n        on: j,\r\n        get __triggerOnEvent() {\r\n          return k\r\n        },\r\n        get __triggerSubscribeEvent() {\r\n          return i\r\n        }\r\n      }\r\n    }, window.WeixinJSBridge = window.__global.WeixinJSBridge = window.__global.getNewWeixinJSBridge('global'), window.__global.WeixinJSBridgeMap = {\r\n      __globalBridge: window.WeixinJSBridge\r\n    }, __devtoolsConfig.online && __devtoolsConfig.autoTest && setInterval(() => {\r\n      console.clear()\r\n    }, 1e4);\r\n    try {\r\n      var l = new window.__global.XMLHttpRequest;\r\n      l.responseType = 'text', l.open('GET', `http://${window.location.host}/calibration/${Date.now()}`, !0), l.send()\r\n    } catch (a) {}\r\n  }\r\n复制代码在 js/extensions/gamenaitveview/index.js 中找到：299: function(a, b, c) {\r\n    'use strict';\r\n    Object.defineProperty(b, '__esModule', {\r\n      value: !0\r\n    });\r\n    var d = c(242),\r\n      e = c(241),\r\n      f = c(243),\r\n      g = c(244);\r\n    window.WeixinJSBridge = {\r\n      on: d.a,\r\n      invoke: e.a,\r\n      publish: f.a,\r\n      subscribe: g.a\r\n    }\r\n  },\r\n复制代码在 js/extensions/pageframe/index.js 中找到：317: function(a, b, c) {\r\n    'use strict';\r\n\r\n    function d() {\r\n      window.WeixinJSBridge = {\r\n        on: e.a,\r\n        invoke: f.a,\r\n        publish: g.a,\r\n        subscribe: h.a\r\n      }, k.a.init();\r\n      let a = document.createEvent('UIEvent');\r\n      a.initEvent('WeixinJSBridgeReady', !1, !1), document.dispatchEvent(a), i.a.init()\r\n    }\r\n    Object.defineProperty(b, '__esModule', {\r\n      value: !0\r\n    });\r\n    var e = c(254),\r\n      f = c(253),\r\n      g = c(255),\r\n      h = c(256),\r\n      i = c(86),\r\n      j = c(257),\r\n      k = c.n(j);\r\n    'complete' === document.readyState ? d() : window.addEventListener('load', function() {\r\n      d()\r\n    })\r\n  },\r\n复制代码我们都看到了 WeixinJSBridge 的定义。分别都有 on 、 invoke 、 publish 、 subscribe 这个几个关键方法。拿 invoke 举例，在 js/extensions/appservice/index.js 中发现这段代码：f (!r) p[b] = s, f.send({\r\n    command: 'APPSERVICE_INVOKE',\r\n    data: {\r\n        api: c,\r\n        args: e,\r\n        callbackID: b\r\n    }\r\n});\r\n复制代码在 js/extensions/pageframe/index.js 中发现这段代码：g[d] = c, e.a.send({\r\n    command: 'WEBVIEW_INVOKE',\r\n    data: {\r\n        api: a,\r\n        args: b,\r\n        callbackID: d\r\n    }\r\n})\r\n\r\n复制代码简单的分析得知：字段 command 用来区分行为， invoke 用来调用 Native 的 Api。在不同的来源要使用不同的前缀。 data 里面包含 Api 名，参数。另外 callbackID 指定接受回调的方法句柄。Appservice 和 Webview 使用的通信协议是一致的。我们不能在代码里使用 BOM 和 DOM 是因为根本没有，另一方面也不希望 JS 代码直接操作视图。在开发工具中 remote-helper.js 中找到了这样的代码：const vm = require(\"vm\");\r\n\r\nconst vmGlobal = {\r\n    require: undefined,\r\n    eval: undefined,\r\n    process: undefined,\r\n    setTimeout(...args) {\r\n        //...省略代码\r\n        return timerCount;\r\n    },\r\n    clearTimeout(id) {\r\n        const timer = timers[id];\r\n        if (timer) {\r\n            clearTimeout(timer);\r\n            delete timers[id];\r\n        }\r\n    },\r\n    setInterval(...args) {\r\n        //...省略代码\r\n        return timerCount;\r\n    },\r\n    clearInterval(id) {\r\n        const timer = timers[id];\r\n        if (timer) {\r\n            clearInterval(timer);\r\n            delete timers[id];\r\n        }\r\n    },\r\n    console: (() => {\r\n        //...省略代码\r\n        return consoleClone;\r\n    })()\r\n};\r\nconst jsVm = vm.createContext(vmGlobal);\r\n// 省略大量代码...\r\nfunction loadCode(filePath, sourceURL, content) {\r\n    let ret;\r\n    try {\r\n        const script = typeof content === 'string' ? content : fs.readFileSync(filePath, 'utf-8').toString();\r\n        ret = vm.runInContext(script, jsVm, {\r\n            filename: sourceURL,\r\n        });\r\n    }\r\n    catch (e) {\r\n        // something went wrong in user code\r\n        console.error(e);\r\n    }\r\n    return ret;\r\n}\r\n复制代码这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作， 同时对于传递的数据和响应时间也能做到监控。一方面程序的行为受到了极大限制， 另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。这样的结构也说明了小程序的动画和绘图 API 被设计成生成一个最终对象而不是一步一步执行的样子， 原因就是 Json 格式的数据传递和解析相比与原生 API 都是损耗不菲的，如果频繁调用很可能损耗过多性能，进而影响用户体验。下载小程序完整包App Service - Life Cylce面试题1.动画需要绑定在 data 上，而绘图却不用。你觉得是为什么呢？var context = wx.createCanvasContext('firstCanvas')\r\n    \r\ncontext.setStrokeStyle(\"#00ff00\")\r\ncontext.setLineWidth(5)\r\ncontext.rect(0, 0, 200, 200)\r\ncontext.stroke()\r\ncontext.setStrokeStyle(\"#ff0000\")\r\ncontext.setLineWidth(2)\r\ncontext.moveTo(160, 100)\r\ncontext.arc(100, 100, 60, 0, 2 * Math.PI, true)\r\ncontext.moveTo(140, 100)\r\ncontext.arc(100, 100, 40, 0, Math.PI, false)\r\ncontext.moveTo(85, 80)\r\ncontext.arc(80, 80, 5, 0, 2 * Math.PI, true)\r\ncontext.moveTo(125, 80)\r\ncontext.arc(120, 80, 5, 0, 2 * Math.PI, true)\r\ncontext.stroke()\r\ncontext.draw()\r\n复制代码Page({\r\n  data: {\r\n    animationData: {}\r\n  },\r\n  onShow: function(){\r\n    var animation = wx.createAnimation({\r\n      duration: 1000,\r\n  \t  timingFunction: 'ease',\r\n    })\r\n\r\n    this.animation = animation\r\n    \r\n    animation.scale(2,2).rotate(45).step()\r\n    \r\n    this.setData({\r\n      animationData:animation.export()\r\n    })\r\n  }\r\n})\r\n复制代码2.小程序的 Http Rquest 请求是不是用的浏览器 Fetch API?知识点考察知道 Request 是由 Native 实现的JSCore 是不带 Http Request、Websocket、Storage等功能的，那是 Webkit 带的小程序的 wx.request 是不是遵循 fetch API 规范实现的呢？答案，显然不是。因为没有 PromiseView - WXMLWXML（WeiXin Markup Language）支持数据绑定支持逻辑算术、运算支持模板、引用支持添加事件（bindtap）Wxml编译器：Wcc 把 Wxml文件 转为 JS执行方式：Wcc index.wxml使用 Virtual DOM，进行局部更新View - WXSSWXSS(WeiXin Style Sheets)wxss编译器：wcsc 把wxss文件转化为 js执行方式： wcsc index.wxss支持大部分CSS特性亲测包含但不限于如下内容：TransitionAnimationKeyframesborder-radiuscalc()选择器，除了官方文档列出的，其实还支持element>elementelement+elementelement elementelement:first-letterelement:first-lineelement:first-childelement:last-childelement~elementelement:first-of-typeelement:last-of-typeelement:only-of-typeelement:only-childelement:nth-child(n)element:nth-last-child(n)element:nth-of-type(n)element:nth-last-of-type(n):rootelement:empty:not(element)iconfont建议 Css3 的特性都可以做一下尝试。尺寸单位 rpxrpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。公式：const dsWidth = 750\r\n\r\nexport const screenHeightOfRpx = function () {\r\n  return 750 / env.screenWidth * env.screenHeight\r\n}\r\n\r\nexport const rpxToPx = function (rpx) {\r\n  return env.screenWidth / 750 * rpx\r\n}\r\n\r\nexport const pxToRpx = function (px) {\r\n  return 750 / env.screenWidth * px\r\n}\r\n\r\n复制代码可以了解一下 pr2rpx-loader 这个库。样式导入使用 @import 语句可以导入外联样式表， @import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。内联样式静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析， 请尽量避免将静态的样式写进 style 中，以免影响渲染速度 。全局样式与局部样式定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。iconfont截止20180810小程序未来有计划支持字体。参考微信公开课。小程序开发与平时 Web开发类似，也可以使用字体图标，但是 src:url() 无论本地还是远程地址都不行，base64 值则都是可以显示的。将 ttf 文件转换成 base64。打开这个平台 transfonter.org/。点击 Add fonts 按钮，加载ttf格式的那个文件。将下边的 base64 encode 改为 on。点击 Convert 按钮进行转换，转换后点击 download 下载。复制下载的压缩文件中的 stylesheet.css 的内容到 font.wxss ，并且将 icomoon 中的 style.css 除了 @font-face 所有的代码也复制到 font.wxss 并将i选择器换成 .iconfont，最后：<text class=\"iconfont icon-home\" style=\"font-size:50px;color:red\"></text>\r\n复制代码View - Component小程序提供了一系列组件用于开发业务功能，按照功能与HTML5的标签进行对比如下：小程序的组件基于Web Component标准使用Polymer框架实现Web ComponentView - Native Component目前Native实现的组件有cavnasvideomaptextareaNative组件层在 WebView 层之上。这目前带来了一些问题：Native 实现的组件会遮挡其他组件WebView 渲染出来的视图在滚动时，Native 实现的组件需要更新位置，这会带来性能问题，在安卓机器上比较明显小程序原生组件 cover-view 可以覆盖 cavnas video 等，但是也有一下弊端，比如在 cavnas 上覆盖 cover-view ，就会发现坐标系不统一处理麻烦目前小程序的问题或限制截止20180810包含但不限于：小程序仍然使用 WebView 渲染，并非原生渲染。（部分原生）服务端接口返回的头无法执行，比如：Set-Cookie。依赖浏览器环境的 JS 库不能使用。不能使用 npm，但是可以自搭构建工具或者使用 mpvue。（未来官方有计划支持）不能使用 ES7，可以自己用babel+webpack自搭或者使用 mpvue。不支持使用自己的字体（未来官方计划支持）。可以用 base64 的方式来使用 iconfont。小程序不能发朋友圈（可以通过保存图片到本地，发图片到朋友前。二维码可以使用B接口）。获取二维码/小程序接口的限制。B 接口 scene 最大32个可见字符。AC 接口总共生成的码数量限制为 100,000，请谨慎调用。真机扫描二维码只能跳转到线上版本，所以测试环境下只可通过开发者工具的通过二维码编译进行调试。没有发布到线上版本的小程序页面路径会导致生成二维码失败，需要先将添加了页面的小程序发布到线上版本。小程序推送只能使用“服务通知” 而且需要用户主动触发提交 formId，formId 只有7天有效期。（现在的做法是在每个页面都放入form并且隐藏以此获取更多的 formId。后端使用原则为：优先使用有效期最短的）小程序大小限制 2M，分包总计不超过 8M转发（分享）小程序不能拿到成功结果，原来可以。链接（小游戏造的孽）拿到相同的 unionId 必须绑在同一个开放平台下。开放平台绑定限制：50个移动应用10个网站50个同主体公众号5个不同主体公众号50个同主体小程序5个不同主体小程序公众号关联小程序，链接所有公众号都可以关联小程序。一个公众号可关联10个同主体的小程序，3个不同主体的小程序。一个小程序可关联500个公众号。公众号一个月可新增关联小程序13次，小程序一个月可新增关联500次。一个公众号关联的10个同主体小程序和3个非同主体小程序可以互相跳转品牌搜索不支持金融、医疗小程序授权需要用户主动点击小程序不提供测试 access_token安卓系统下，小程序授权获取用户信息之后，删除小程序再重新获取，并重新授权，得到旧签名，导致第一次授权失败开发者工具上，授权获取用户信息之后，如果清缓存选择全部清除，则即使使用了wx.checkSession，并且在session_key有效期内，授权获取用户信息也会得到新的session_key小程序HTTP2支持情况HTTP2支持情况：模拟器与真机均不支持为了验证小程序对HTTP的支持适配情况，我找了两个服务器做测试，一个是网上搜索到支持HTTP2的服务器，一个是我本地起的一个HTTP2服务器。测试中所有请求方法均使用 wx.request。网上支持HTTP2的服务器： HTTPs://www.snel.com:443在Chrome上查看该服务器为 HTTP2在模拟器上请求该接口， 请求头 的HTTP版本为HTTP1.1，模拟器不支持HTTP2由于小程序线上环境需要在项目管理里配置请求域名，而这个域名不是我们需要的请求域名，没必要浪费一个域名位置，所以打开不验证域名，TSL 等选项请求该接口，通过抓包工具表现与模拟器相同HTTP2服务器需要对小程序做兼容性适配由上可以看出，在真机与模拟器都不支持 HTTP2，但是都是成功请求的，并且 响应头 里的 HTTP 版本都变成了HTTP1.1 版本，说明服务器对 HTTP1.1 做了兼容性适配。本地新启一个 node 服务器，返回 JSON 为请求的 HTTP 版本如果服务器只支持 HTTP2，在模拟器请求时发生了一个 ALPN 协议的错误。并且提醒使用适配 HTTP1当把服务器的 allowHTTP1 ，设置为 true ，并在请求时处理相关相关请求参数后，模拟器能正常访问接口，并打印出对应的 HTTP 请求版本授权获取用户信息流程session_key 有有效期，有效期并没有被告知开发者，只知道用户越频繁使用小程序，session_key 有效期越长在调用 wx.login 时会直接更新 session_key，导致旧 session_key 失效小程序内先调用 wx.checkSession 检查登录态，并保证没有过期的 session_key 不会被更新，再调用 wx.login 获取 code。接着用户授权小程序获取用户信息，小程序拿到加密后的用户数据，把加密数据和 code 传给后端服务。后端通过 code 拿到 session_key 并解密数据，将解密后的用户信息返回给小程序面试题：先授权获取用户信息再 login 会发生什么？用户授权时，开放平台使用旧的 session_key 对用户信息进行加密。调用 wx.login 重新登录，会刷新 session_key，这时后端服务从开放平台获取到新 session_key，但是无法对老 session_key 加密过的数据解密，用户信息获取失败在用户信息授权之前先调用 wx.checkSession 呢？wx.checkSession 检查登录态，并且保证 wx.login 不会刷新 session_key，从而让后端服务正确解密数据。但是这里存在一个问题，如果小程序较长时间不用导致 session_key 过期，则 wx.login 必定会重新生成 session_key，从而再一次导致用户信息解密失败。性能优化我们知道view部分是运行在webview上的，所以前端领域的大多数优化方式都有用。我们知道view部分是运行在webview上的，所以前端领域的大多数优化方式都有用。我们知道view部分是运行在webview上的，所以前端领域的大多数优化方式都有用。加载优化代码包的大小是最直接影响小程序加载启动速度的因素。代码包越大不仅下载速度时间长，业务代码注入时间也会变长。所以最好的优化方式就是减少代码包的大小。小程序加载的三个阶段的表示。优化方式代码压缩。及时清理无用代码和资源文件。减少代码包中的图片等资源文件的大小和数量。分包加载。首屏加载的体验优化建议提前请求: 异步数据请求不需要等待页面渲染完成。利用缓存: 利用 storage API 对异步请求数据进行缓存，二次启动时先利用缓存数据渲染页面，在进行后台更新。避免白屏：先展示页面骨架页和基础内容。及时反馈：即时地对需要用户等待的交互操作给出反馈，避免用户以为小程序无响应。使用分包加载优化在构建小程序分包项目时，构建会输出一个或多个功能的分包，其中每个分包小程序必定含有一个主包，所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本，而分包则是根据开发者的配置进行划分。在小程序启动时，默认会下载主包并启动主包内页面，如果用户需要打开分包内某个页面，客户端会把对应分包下载下来，下载完成后再进行展示。优点：对开发者而言，能使小程序有更大的代码体积，承载更多的功能与服务对用户而言，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能限制：整个小程序所有分包大小不超过 8M单个分包/主包大小不能超过 2M原生分包加载的配置假设支持分包的小程序目录结构如下：├── app.js\r\n├── app.json\r\n├── app.wxss\r\n├── packageA\r\n│   └── pages\r\n│       ├── cat\r\n│       └── dog\r\n├── packageB\r\n│   └── pages\r\n│       ├── apple\r\n│       └── banana\r\n├── pages\r\n│   ├── index\r\n│   └── logs\r\n└── utils\r\n\r\n复制代码开发者通过在 app.json subPackages 字段声明项目分包结构：{\r\n  \"pages\":[\r\n    \"pages/index\",\r\n    \"pages/logs\"\r\n  ],\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"packageA\",\r\n      \"pages\": [\r\n        \"pages/cat\",\r\n        \"pages/dog\"\r\n      ]\r\n    }, {\r\n      \"root\": \"packageB\",\r\n      \"pages\": [\r\n        \"pages/apple\",\r\n        \"pages/banana\"\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\n复制代码分包原则声明 subPackages 后，将按 subPackages 配置路径进行打包，subPackages 配置路径外的目录将被打包到 app（主包） 中app（主包）也可以有自己的 pages（即最外层的 pages 字段subPackage 的根目录不能是另外一个 subPackage 内的子目录首页的 TAB 页面必须在 app（主包）内引用原则packageA 无法 require packageB JS 文件，但可以 require app、自己 package 内的 JS 文件packageA 无法 import packageB 的 template，但可以 require app、自己 package 内的 templatepackageA 无法使用 packageB 的资源，但可以使用 app、自己 package 内的资源官方即将推出分包预加载独立分包渲染性能优化每次 setData 的调用都是一次进程间通信过程，通信开销与 setData 的数据量正相关。setData 会引发视图层页面内容的更新，这一耗时操作一定时间中会阻塞用户交互。setData 是小程序开发使用最频繁，也是最容易引发性能问题的。避免不当使用 setData使用 data 在方法间共享数据， 可能增加 setData 传输的数据量。 。data 应仅包括与页面渲染相关的数据。使用 setData 传输大量数据，**通讯耗时与数据正相关，页面更新延迟可能造成页面更新开销增加。**仅传输页面中发生变化的数据，使用 setData 的特殊 key 实现局部更新。短时间内频繁调用 setData，**操作卡顿，交互延迟，阻塞通信，页面渲染延迟。**避免不必要的 setData，对连续的setData调用进行合并。在后台页面进行 setData，**抢占前台页面的渲染资源。**页面切入后台后的 setData 调用，延迟到页面重新展示时执行。避免不当使用onPageScroll只在有必要的时候监听 pageScroll 事件。不监听，则不会派发。避免在 onPageScroll 中执行复杂逻辑避免在 onPageScroll 中频繁调用 setData避免滑动时频繁查询节点信息（SelectQuery）用以判断是否显示，部分场景建议使用节点布局橡胶状态监听（inersectionObserver）替代使用自定义组件在需要频繁更新的场景下，自定义组件的更新只在组件内部进行，不受页面其他部分内容复杂性影响。官方小程序技术能力规划自定义组件2.0小程序的几个页面间，存在一些相同或是类似的区域，这时候可以把这些区域逻辑封装成一个自定义组件，代码就可以重用，或者对于比较独立逻辑，也可以把它封装成一个自定义组件，也就是微信去年发布的自定义组件，它让代码得到复用、减少代码量，更方便模块化，优化代码架构组织，也使得模块清晰，后期更好地维护，从而保证更好的性能。但微信打算在原来的基础上推出的自定义组件 2.0，它将拥有更高级的性能：usingComponents 计划支持全局定义和通配符定义：这意味着不用在每个页面反复定义，可以批量导入目录下的所有自定义组件计划支持类似 Computed 和 watch 的功能，它能使代码逻辑更清晰计划支持 Component 构造器插件，在实例化一个自定义组件的时候，允许你在构造器的这个阶段，加入一些逻辑，方便进行一些扩展，甚至是可以扩展成 Vue 的语法npm支持目前小程序开发的痛点是：开源组件要手动复制到项目，后续更新组件也需要手动操作。不久的将来，小程序将支持npm包管理，有了这个之后，想要引入一些开源的项目就变得很简单了，只要在项目里面声明，然后用简单的命令安装，就可以使用了。官方自定义组件微信小程序团队表示，他们在考虑推出一些官方自定义组件，为什么不内置到基础库里呢？因为内置组件要提供给开发者，这个组件一定是开发者很难实现或者是无法实现的一个能力。所以他们更倾向于封装成自定义组件，想基于这些内置组件里，封装一些比较常见的、交互逻辑比较复杂的组件给大家使用，让大家更容易开发。类似弹幕组件，开发者就不用关注弹幕怎么飘，可以节省开发者的开发成本。同时，他们也想给开发者提供一些规范和一些模板，让开发者设计出好用的自定义组件，更好地被大家去使用。添加体验评分当小程序加载太慢时，可能会导致用户的流失，而小程序的开发者可能会面临着不知道如何定位问题或不知如何解决问题的困境。为此，小程序即将推出一个体验评分的功能，这是为了帮助开发者可以检查出小程序有一些什么体验不好的地方，也会同时给出一份优化的指引建议。原生组件同层渲染小程序在最初的技术选型时，引入了原生组件的概念，因为原生组件可以使小程序的能力更加丰富，比如地图、音视频的能力，但是原生组件是由客户端原生渲染的，导致了原生组件的层级是最高的，开发者很容易遇到打开调试的问题，发现视频组件挡在了 vConsole 上。为了解决这个问题，当时微信做了一个过渡的方案：cover-view。cover-view可以覆盖在原生组件之上，这一套方案解决了大部分的需求场景。比如说视频组件上很多的按钮、标题甚至还有动画的弹幕，这些都是用 cover-view 去实现的，但它还是没有完全解决原生组件的开发体验问题，因为 cover-view 有一些限制：无法与其他组件混在一起渲染没有完整的触摸事件cover-view 对样式的表现有差异cover-view 对样式的支持度不够高因此微信决定将用同层渲染取代 cover-view，它能像普通组件一样使用，原生组件的层级不再是最高，而是和其他的非原生组件在同一层级渲染，可完全由 z-index 控制，可完全支持触摸事件。微信表示，同层渲染在 iOS 平台小程序上已经开始内测，会很快开放给开发者，Android 平台已经取得突破性进展，目前正在做一轮封装的工作，开放指日可待。wepy vs mpvue数据流管理相比传统的小程序框架，这个一直是我们作为资深开发者比较期望去解决的，在 Web 开发中，随着 Flux、Redux、Vuex 等多个数据流工具出现，我们也期望在业务复杂的小程序中使用。WePY 默认支持 Redux，在脚手架生成项目的时候可以内置Mpvue 作为 Vue 的移植版本，当然支持 Vuex，同样在脚手架生成项目的时候可以内置组件化如果你和我们一样，经历了从无到有的小程序业务开发，建议阅读【小程序的组件化开发】章节，进行官方语法的组件库开发（从基础库 1.6.3 开始，官方提供了组件化解决方案）。WePY 类似 Vue 实现了单文件组件，最大的差别是文件后缀 .wpy，只是写法上会有差异，具体可以查看【主流框架使用案例 1：WePY】章节，学习起来有一定成本，不过也会很快适应：export default class Index extends wepy.page {}\r\n复制代码Mpvue 作为 Vue 的移植版本，支持单文件组件，template、script 和 style 都在一个 .vue 文件中，和 vue 的写法类似，所以对 Vue 开发熟悉的同学会比较适应。工程化所有的小程序开发依赖官方提供的开发者工具。开发者工具简单直观，对调试小程序很有帮助，现在也支持腾讯云（目前我们还没有使用，但是对新的一些开发者还是有帮助的），可以申请测试报告查看小程序在真实的移动设备上运行性能和运行效果，但是它本身没有类似前端工程化中的概念和工具。wepy 内置了构建，通过 wepy init 命令初始化项目，大致流程如下：wepy-cli 会判断模版是在远程仓库还是在本地，如果在本地则会立即跳到第 3 步，反之继续进行。会从远程仓库下载模版，并保存到本地。询问开发者 Project name 等问题，依据开发者的回答，创建项目。mpvue 沿用了 vue 中推崇的 webpack 作为构建工具，但同时提供了一些自己的插件以及配置文件的一些修改，比如：不再需要 html-webpack-plugin基于 webpack-dev-middleware 修改成 webpack-dev-middleware-hard-disk最大的变化是基于 webpack-loader 修改成 mpvue-loader但是配置方式还是类似，分环境配置文件，最终都会编译成小程序支持的目录结构和文件后缀。综合比较选型的个人看法先说结论：选择 mpvue。wepy vs mpvue。理由：工程化原生开发因为不带工程化，诸如NPM包（未来会引入）、ES7、图片压缩、PostCss、pug、ESLint等等不能用。如果自己要搭工程化，不如直接使用wepy或mpvue。mpvue和wepy都可以和小程序原生开发混写。， 参考wepy 。 而问题在于wepy没有引入webpack(wepy@2.0.x依然没有引入)，以上说的这些东西都要造轮子（作者造或自己造）。没有引入 Webpack 是一个重大的硬伤。社区维护的成熟 Webpack 显然更稳定，轮子更多。维护wepy 也是社区维护的，是官方的？其实 wepy 的主要开发者只有作者一人，附上一个 contrubutors 链接。另外被官方招安了也是后来的事，再说腾讯要有精力帮着一起维护好 wepy，为什么不花精力在小程序原生开发上呢？再来看看 mpvue，是美团一个前端小组维护的。学习成本Vue 的学习曲线比较平缓。mpvue 是 Vue的子集。所以 mpvue 的学习成本会低于 wepy。尤其是之前技术栈有学过用过 Vue 的。未来规划mpvue 已经支持 web 和小程序。因为 mpvue 基于AST，所以未来可以支持支付宝小程序和快应用。他们也是有这样的规划。请在需求池下面自己找坑两者都有各自的坑。但是我觉得有一些wepy的坑是没法容忍的。比如 repeat组建里面用computed得到的列表全是同一套数据 而且1.x是没法解决的。 wepy和mpvue我都开发过完整小程序的体验下，我觉得wepy的坑更多，而且wepy有些坑碍于架构设计没办法解决。mpvueVue.js 小程序版, fork 自 vuejs/vue@2.4.1，保留了 vue runtime 能力，添加了小程序平台的支持。 mpvue 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心， mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。框架原理两个大方向mpvue\r\nmpvue-loader\r\n七个具体问题要了解 mpvue 原理必然要了解 Vue 原理，这是大前提。但是要讲清楚 Vue 原理需要花费大量的篇幅，不如参考 learnVue 。现在假设您对 Vue 原理有个大概的了解。由于 Vue 使用了 Virtual DOM，所以 Virtual DOM 可以在任何支持 JavaScript 语言的平台上操作，譬如说目前 Vue 支持浏览器平台或 weex，也可以是 mp(小程序)。那么最后 Virtual DOM 如何映射到真实的 DOM 节点上呢？vue为平台做了一层适配层，浏览器平台见 runtime/node-ops.js 、weex平台见 runtime/node-ops.js ，小程序见 runtime/node-ops.js 。不同平台之间通过适配层对外提供相同的接口，Virtual DOM进行操作Real DOM节点的时候，只需要调用这些适配层的接口即可，而内部实现则不需要关心，它会根据平台的改变而改变。所以思路肯定是往增加一个 mp 平台的 runtime 方向走。但问题是小程序不能操作 DOM，所以 mp 下的 node-ops.js 里面的实现都是直接 return obj 。新 Virtual DOM 和旧 Virtual DOM 之间需要做一个 patch，找出 diff。patch完了之后的 diff 怎么更新视图，也就是如何给这些 DOM 加入 attr、class、style 等 DOM 属性呢？ Vue 中有 nextTick 的概念用以更新视图，mpvue这块对于小程序的 setData 应该怎么处理呢？另外个问题在于小程序的 Virtual DOM 怎么生成？也就是怎么将 template 编译成 render function 。这当中还涉及到 运行时-编译器-vs-只包含运行时 ，显然如果要提高性能、减少包大小、输出 wxml、mpvue 也要提供预编译的能力。因为要预输出 wxml 且没法动态改变 DOM，所以动态组件，自定义 render，和 <script type=\"text/x-template\"> 字符串模版等都不支持(参考)。另外还有一些其他问题，最后总结一下render function\r\nplatform/mp的目录结构.\r\n├── compiler //解决问题1，mpvue-template-compiler源码部分\r\n├── runtime //解决问题3 4 5 6 7\r\n├── util //工具方法\r\n├── entry-compiler.js //mpvue-template-compiler的入口。package.json相关命令会自动生成mpvue-template-compiler这个package。\r\n├── entry-runtime.js //对外提供Vue对象，当然是mpvue\r\n└── join-code-in-build.js //编译出SDK时的修复\r\n复制代码后面的内容逐步解答这几个问题，也就弄明白了原理mpvue-loadermpvue-loader 是 vue-loader 的一个扩展延伸版，类似于超集的关系，除了 vue-loader 本身所具备的能力之外，它还会利用 mpvue-template-compiler 生成 render function 。entry它会从 webpack 的配置中的 entry 开始，分析依赖模块，并分别打包。在entry 中 app 属性及其内容会被打包为微信小程序所需要的 app.js／app.json／app.wxss，其余的会生成对应的页面page.js/page.json/page.wxml/page.wxss，如示例的 entry 将会生成如下这些文件，文件内容下文慢慢讲来：// webpack.config.js\r\n{\r\n    // ...\r\n    entry: {\r\n        app: resolve('./src/main.js'),               // app 字段被识别为 app 类型\r\n        index: resolve('./src/pages/index/main.js'),   // 其余字段被识别为 page 类型\r\n        'news/home': resolve('./src/pages/news/home/index.js')\r\n    }\r\n}\r\n\r\n// 产出文件的结构\r\n.\r\n├── app.js\r\n├── app.json\r\n├──· app.wxss\r\n├── components\r\n│   ├── card$74bfae61.wxml\r\n│   ├── index$023eef02.wxml\r\n│   └── news$0699930b.wxml\r\n├── news\r\n│   ├── home.js\r\n│   ├── home.wxml\r\n│   └── home.wxss\r\n├── pages\r\n│   └── index\r\n│       ├── index.js\r\n│       ├── index.wxml\r\n│       └── index.wxss\r\n└── static\r\n    ├── css\r\n    │   ├── app.wxss\r\n    │   ├── index.wxss\r\n    │   └── news\r\n    │       └── home.wxss\r\n    └── js\r\n        ├── app.js\r\n        ├── index.js\r\n        ├── manifest.js\r\n        ├── news\r\n        │   └── home.js\r\n        └── vendor.js\r\n复制代码wxml 每一个 .vue 的组件都会被生成为一个 wxml 规范的 template，然后通过 wxml 规范的 import 语法来达到一个复用，同时组件如果涉及到 props 的 data 数据，我们也会做相应的处理，举个实际的例子：<template>\r\n    <div class=\"my-component\" @click=\"test\">\r\n        <h1>{{msg}}</h1>\r\n        <other-component :msg=\"msg\"></other-component>\r\n    </div>\r\n</template>\r\n<script>\r\nimport otherComponent from './otherComponent.vue'\r\n\r\nexport default {\r\n  components: { otherComponent },\r\n  data () {\r\n    return { msg: 'Hello Vue.js!' }\r\n  },\r\n  methods: {\r\n    test() {}\r\n  }\r\n}\r\n</script>\r\n复制代码这样一个 Vue 的组件的模版部分会生成相应的 wxml<import src=\"components/other-component$hash.wxml\" />\r\n<template name=\"component$hash\">\r\n    <view class=\"my-component\" bindtap=\"handleProxy\">\r\n        <view class=\"_h1\">{{msg}}</view>\r\n        <template is=\"other-component$hash\" wx:if=\"{{ $c[0] }}\" data=\"{{ ...$c[0] }}\"></template>\r\n    </view>\r\n</template>\r\n复制代码可能已经注意到了 other-component(:msg=\"msg\") 被转化成了 。mpvue 在运行时会从根组件开始把所有的组件实例数据合并成一个树形的数据，然后通过 setData 到 appData, $c 是 $children 的缩写。至于那个 0 则是我们的 compiler 处理过后的一个标记，会为每一个子组件打一个特定的不重复的标记。 树形数据结构如下：// 这儿数据结构是一个数组，index 是动态的\r\n{\r\n  $child: {\r\n    '0'{\r\n      // ... root data\r\n      $child: {\r\n        '0': {\r\n          // ... data\r\n          msg: 'Hello Vue.js!',\r\n          $child: {\r\n            // ...data\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n复制代码wxss这个部分的处理同 web 的处理差异不大，唯一不同在于通过配置生成 .css 为 .wxss ，其中的对于 css 的若干处理，在 postcss-mpvue-wxss 和 px2rpx-loader 这两部分的文档中又详细的介绍。app.json／page.json 1.1.1 以上推荐和小程序一样，将 app.json／page.json 放到页面入口处，使用 copy-webpack-plugin copy 到对应的生成位置。1.1.1 以下这部分内容来源于 app 和 page 的 entry 文件，通常习惯是 main.js，你需要在你的入口文件中 export default { config: {} }，这才能被我们的 loader 识别为这是一个配置，需要写成 json 文件。import Vue from 'vue';\r\nimport App from './app';\r\n\r\nconst vueApp = new Vue(App);\r\nvueApp.$mount();\r\n\r\n// 这个是我们约定的额外的配置\r\nexport default {\r\n    // 这个字段下的数据会被填充到 app.json ／ page.json\r\n    config: {\r\n        pages: ['static/calendar/calendar', '^pages/list/list'], // Will be filled in webpack\r\n        window: {\r\n            backgroundTextStyle: 'light',\r\n            navigationBarBackgroundColor: '#455A73',\r\n            navigationBarTitleText: '美团汽车票',\r\n            navigationBarTextStyle: '#fff'\r\n        }\r\n    }\r\n};\r\n复制代码同时，这个时候，我们会根据 entry 的页面数据，自动填充到 app.json 中的 pages 字段。 pages 字段也是可以自定义的，约定带有 ^ 符号开头的页面，会放到数组的最前面。style scoped 在 vue-loader 中对 style scoped 的处理方式是给每个样式加一个 attr 来标记 module-id，然后在 css 中也给每条 rule 后添加 [module-id]，最终可以形成一个 css 的“作用域空间”。在微信小程序中目前是不支持 attr 选择器的，所以我们做了一点改动，把 attr 上的 [module-id] 直接写到了 class 里，如下：<!-- .vue -->\r\n<template>\r\n    <div class=\"container\">\r\n        // ...\r\n    </div>\r\n</template>\r\n<style scoped>\r\n    .container {\r\n        color: red;\r\n    }\r\n</style>\r\n\r\n<!-- vue-loader -->\r\n<template>\r\n    <div class=\"container\" data-v-23e58823>\r\n        // ...\r\n    </div>\r\n</template>\r\n<style scoped>\r\n    .container[data-v-23e58823] {\r\n        color: red;\r\n    }\r\n</style>\r\n\r\n<!-- mpvue-loader -->\r\n<template>\r\n    <div class=\"container data-v-23e58823\">\r\n        // ...\r\n    </div>\r\n</template>\r\n<style scoped>\r\n    .container.data-v-23e58823 {\r\n        color: red;\r\n    }\r\n</style>\r\n复制代码compiler生产出的内容是：(function(module, __webpack_exports__, __webpack_require__) {\r\n\r\n\"use strict\";\r\n// mpvue-template-compiler会利用AST预编译生成一个render function用以生成Virtual DOM。\r\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\r\n  // _c创建虚拟节点，参考https://github.com/Meituan-Dianping/mpvue/blob/master/packages/mpvue/index.js#L3606\r\n  // 以及https://github.com/Meituan-Dianping/mpvue/blob/master/packages/mpvue/index.js#L3680\r\n  return _c('div', {\r\n    staticClass: \"my-component\"\r\n  }, [_c('h1', [_vm._v(_vm._s(_vm.msg))]), _vm._v(\" \"), _c('other-component', {\r\n    attrs: {\r\n      \"msg\": _vm.msg,\r\n      \"mpcomid\": '0'\r\n    }\r\n  })], 1)\r\n}\r\n\r\n// staticRenderFns的作用是静态渲染，在更新时不会进行patch，优化性能。而staticRenderFns是个空数组。\r\nvar staticRenderFns = []\r\nrender._withStripped = true\r\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\r\nif (false) {\r\n  module.hot.accept()\r\n  if (module.hot.data) {\r\n     require(\"vue-hot-reload-api\").rerender(\"data-v-54ad9125\", esExports)\r\n  }\r\n}\r\n\r\n/***/ })\r\n复制代码compilercompiler相关，也就是template预编译这块，可以参考《 聊聊Vue的template编译 》来搞明白。原理是一样的。mpvue自己实现了 export { compile, compileToFunctions, compileToWxml } ( 链接 )其中 compileToWxml 是用来生成wxml，具体代码 在这 。另外mpvue是不需要提供运行时-编译器的，虽然理论上是能够做到的。因为小程序不能操作DOM，即便提供了运行时-编译器也产生不了界面。详细讲解compile过程：1.将vue文件解析成模板对象// mpvue-loader/lib/loader.js\r\nvar parts = parse(content, fileName, this.sourceMap)\r\n复制代码假如vue文件源码如下:<template>\r\n  <view class=\"container-bg\">\r\n    <view class=\"home-container\">\r\n      <home-quotation-view v-for=\"(item, index) in lists\" :key=\"index\" :reason=\"item.reason\" :stockList=\"item.list\" @itemViewClicked=\"itemViewClicked\" />\r\n    </view>\r\n  </view>\r\n</template>\r\n\r\n<script lang=\"js\">\r\nimport homeQuotationView from '@/components/homeQuotationView'\r\nimport topListApi from '@/api/topListApi'\r\n\r\nexport default {\r\n  data () {\r\n    return {\r\n      lists: []\r\n    }\r\n  },\r\n  components: {\r\n    homeQuotationView\r\n  },\r\n  methods: {\r\n    async loadRankList () {\r\n      let {data} = await topListApi.rankList()\r\n      if (data) {\r\n        this.dateTime = data.dt\r\n        this.lists = data.rankList.filter((item) => {\r\n          return !!item\r\n        })\r\n      }\r\n    },\r\n    itemViewClicked (quotationItem) {\r\n      wx.navigateTo({\r\n        url: `/pages/topListDetail/main?item=${JSON.stringify(quotationItem)}`\r\n      })\r\n    }\r\n  },\r\n  onShow () {\r\n    this.loadRankList()\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"stylus\" scoped>\r\n  .container-bg\r\n    width 100%\r\n    height 100%\r\n    background-color #F2F4FA\r\n\r\n  .home-container\r\n    width 100%\r\n    height 100%\r\n    overflow-x hidden\r\n\r\n</style>\r\n复制代码调用 parse(content, fileName, this.sourceMap) 函数得到的结果大致如下：{\r\n  template: {\r\n    type: 'template',\r\n    content: '\\n<view class=\"container-bg\">\\n  <view class=\"home-container\">\\n    <home-quotation-view v-for=\"(item, index) in lists\" :key=\"index\" :reason=\"item.reason\" :stockList=\"item.list\" @itemViewClicked=\"itemViewClicked\" />\\n  </view>\\n</view>\\n',\r\n    start: 10,\r\n    attrs: {},\r\n    end: 251\r\n  },\r\n  script: {\r\n    type: 'script',\r\n    content: '\\n\\n\\n\\n\\n\\n\\n\\n\\nimport homeQuotationView from \\'@/components/homeQuotationView\\'\\nimport topListApi from \\'@/api/topListApi\\'\\n\\nexport default {\\n  data () {\\n    return {\\n      lists: []\\n    }\\n  },\\n  components: {\\n    homeQuotationView\\n  },\\n  methods: {\\n    async loadRankList () {\\n      let {data} = await topListApi.rankList()\\n      if (data) {\\n        this.dateTime = data.dt\\n        this.lists = data.rankList.filter((item) => {\\n          return !!item\\n        })\\n      }\\n    },\\n    itemViewClicked (quotationItem) {\\n      wx.navigateTo({\\n        url: `/pages/topListDetail/main?item=${JSON.stringify(quotationItem)}`\\n      })\\n    }\\n  },\\n  onShow () {\\n    this.loadRankList()\\n  }\\n}\\n',\r\n    start: 282,\r\n    attrs: {\r\n      lang: 'js'\r\n    },\r\n    lang: 'js',\r\n    end: 946,\r\n    ...\r\n  },\r\n  styles: [{\r\n    type: 'style',\r\n    content: '\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n.container-bg\\n  width 100%\\n  height 100%\\n  background-color #F2F4FA\\n\\n.home-container\\n  width 100%\\n  height 100%\\n  overflow-x hidden\\n\\n',\r\n    start: 985,\r\n    attrs: [Object],\r\n    lang: 'stylus',\r\n    scoped: true,\r\n    end: 1135,\r\n    ...\r\n  }],\r\n  customBlocks: []\r\n}\r\n复制代码2.调用mpvue-loader/lib/template-compiler/index.js导出的接口并传入上面得到的html模板：var templateCompilerPath = normalize.lib('template-compiler/index')\r\n...\r\nvar defaultLoaders = {\r\n  html: templateCompilerPath + templateCompilerOptions,\r\n  css: options.extractCSS\r\n    ? getCSSExtractLoader()\r\n    : styleLoaderPath + '!' + 'css-loader' + cssLoaderOptions,\r\n  js: hasBuble ? ('buble-loader' + bubleOptions) : hasBabel ? babelLoaderOptions : ''\r\n}\r\n\r\n// check if there are custom loaders specified via\r\n// webpack config, otherwise use defaults\r\nvar loaders = Object.assign({}, defaultLoaders, options.loaders)\r\n复制代码调用mpvue/packages/mpvue-template-compiler/build.js的compile接口：// mpvue-loader/lib/template-compiler/index.js\r\nvar compiled = compile(html, compilerOptions)\r\n复制代码compile方法生产下面的ast(Abstract Syntax Tree)模板，render函数和staticRenderFns{\r\n  ast: {\r\n    type: 1,\r\n    tag: 'view',\r\n    attrsList: [],\r\n    attrsMap: {\r\n      class: 'container-bg'\r\n    },\r\n    parent: undefined,\r\n    children: [{\r\n      type: 1,\r\n      tag: 'view',\r\n      attrsList: [],\r\n      attrsMap: {\r\n        class: 'home-container'\r\n      },\r\n      parent: {\r\n        type: 1,\r\n        tag: 'view',\r\n        attrsList: [],\r\n        attrsMap: {\r\n          class: 'container-bg'\r\n        },\r\n        parent: undefined,\r\n        children: [\r\n          [Circular]\r\n        ],\r\n        plain: false,\r\n        staticClass: '\"container-bg\"',\r\n        static: false,\r\n        staticRoot: false\r\n      },\r\n      children: [{\r\n        type: 1,\r\n        tag: 'home-quotation-view',\r\n        attrsList: [{\r\n          name: ':reason',\r\n          value: 'item.reason'\r\n        }, {\r\n          name: ':stockList',\r\n          value: 'item.list'\r\n        }, {\r\n          name: '@itemViewClicked',\r\n          value: 'itemViewClicked'\r\n        }],\r\n        attrsMap: {\r\n          'v-for': '(item, index) in lists',\r\n          ':key': 'index',\r\n          ':reason': 'item.reason',\r\n          ':stockList': 'item.list',\r\n          '@itemViewClicked': 'itemViewClicked',\r\n          'data-eventid': '{{\\'0-\\'+index}}',\r\n          'data-comkey': '{{$k}}'\r\n        },\r\n        parent: [Circular],\r\n        children: [],\r\n        for: 'lists',\r\n        alias: 'item',\r\n        iterator1: 'index',\r\n        key: 'index',\r\n        plain: false,\r\n        hasBindings: true,\r\n        attrs: [{\r\n          name: 'reason',\r\n          value: 'item.reason'\r\n        }, {\r\n          name: 'stockList',\r\n          value: 'item.list'\r\n        }, {\r\n          name: 'eventid',\r\n          value: '\\'0-\\'+index'\r\n        }, {\r\n          name: 'mpcomid',\r\n          value: '\\'0-\\'+index'\r\n        }],\r\n        events: {\r\n          itemViewClicked: {\r\n            value: 'itemViewClicked',\r\n            modifiers: undefined\r\n          }\r\n        },\r\n        eventid: '\\'0-\\'+index',\r\n        mpcomid: '\\'0-\\'+index',\r\n        static: false,\r\n        staticRoot: false,\r\n        forProcessed: true\r\n      }],\r\n      plain: false,\r\n      staticClass: '\"home-container\"',\r\n      static: false,\r\n      staticRoot: false\r\n    }],\r\n    plain: false,\r\n    staticClass: '\"container-bg\"',\r\n    static: false,\r\n    staticRoot: false\r\n  },\r\n  render: 'with(this){return _c(\\'view\\',{staticClass:\"container-bg\"},[_c(\\'view\\',{staticClass:\"home-container\"},_l((lists),function(item,index){return _c(\\'home-quotation-view\\',{key:index,attrs:{\"reason\":item.reason,\"stockList\":item.list,\"eventid\":\\'0-\\'+index,\"mpcomid\":\\'0-\\'+index},on:{\"itemViewClicked\":itemViewClicked}})}))])}',\r\n  staticRenderFns: [],\r\n  errors: [],\r\n  tips: []\r\n}\r\n复制代码其中的render函数运行的结果是返回 VNode 对象，其实 render 函数应该长下面这样：(function() {\r\n  with(this){\r\n    return _c('div',{   //创建一个 div 元素\r\n      attrs:{\"id\":\"app\"}  //div 添加属性 id\r\n      },[\r\n        _m(0),  //静态节点 header，此处对应 staticRenderFns 数组索引为 0 的 render 函数\r\n        _v(\" \"), //空的文本节点\r\n        (message) //三元表达式，判断 message 是否存在\r\n         //如果存在，创建 p 元素，元素里面有文本，值为 toString(message)\r\n        ?_c('p',[_v(\"\\n    \"+_s(message)+\"\\n  \")])\r\n        //如果不存在，创建 p 元素，元素里面有文本，值为 No message. \r\n        :_c('p',[_v(\"\\n    No message.\\n  \")])\r\n      ]\r\n    )\r\n  }\r\n})\r\n复制代码其中的 _c 就是vue对象的 createElement 方法 (创建元素)， _m 是 renderStatic （渲染静态节点）， _v 是 createTextVNode （创建文本dom）， _s 是 toString （转换为字符串）// src/core/instance/render.js\r\nexport function initRender (vm: Component) {\r\n  ...\r\n  // bind the createElement fn to this instance\r\n  // so that we get proper render context inside it.\r\n  // args order: tag, data, children, normalizationType, alwaysNormalize\r\n  // internal version is used by render functions compiled from templates\r\n  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\r\n  // normalization is always applied for the public version, used in\r\n  // user-written render functions.\r\n  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\r\n  ...\r\n}\r\n\r\n...\r\nVue.prototype._s = toString\r\n...\r\nVue.prototype._m = renderStatic\r\n...\r\nVue.prototype._v = createTextVNode\r\n...\r\n复制代码调用compileWxml方法生产wxml模板，这个方法最终会调用 mpvue/packages/mpvue-template-compiler/build.js的compileToWxml方法将第一步compile出来的模板转成小程序的wxml模板// mpvue-loader/lib/template-compiler/index.js\r\ncompileToWxml.call(this, compiled, html)\r\n复制代码以上解答了问题1、2runtime目录结构.\r\n├── events.js //解答问题5\r\n├── index.js //入口提供Vue对象，以及$mount，和各种初始化\r\n├── liefcycle //解答问题6、7\r\n├── node-ops.js //操作真实DOM的相关实现，因为小程序不能操作DOM，所以这里都是直接返回\r\n├── patch.js //解答问题3\r\n└── render.js //解答问题4\r\n复制代码patch.js和vue使用的 createPatchFunction 保持一致，任然是旧树和新树进行patch产出diff，但是多了一行this.$updateDataToMP()用以更新。render.js两个核心的方法 initDataToMP 、 updateDataToMP 。initDataToMP 收集vm上的data，然后调用小程序Page示例的 setData 渲染。updateDataToMP 在每次patch，也就是依赖收集发现数据改变时更新(参考patch.js代码)，这部分一样会使用 nextTick 和队列。最终使用了节流阀 throttleSetData 。50毫秒用来控制频率以解决频繁修改Data，会造成大量传输Data数据而导致的性能问题。其中 collectVmData 最终也是用到了 formatVmData 。尤其要注意的是一句注释：getVmData 这儿获取当前组件内的所有数据，包含 props、computed 的数据我们又知道，service到view是两个线程间通信，如果Data含有大量数据，增加了传输数据量，加大了传输成本，将会造成性能下降。events.js正如官网所说的，这里使用 eventTypeMap 做了各事件的隐射import { getComKey, eventTypeMap } from '../util/index'\r\n复制代码// 用于小程序的 event type 到 web 的 event\r\nexport const eventTypeMap = {\r\n  tap: ['tap', 'click'],\r\n  touchstart: ['touchstart'],\r\n  touchmove: ['touchmove'],\r\n  touchcancel: ['touchcancel'],\r\n  touchend: ['touchend'],\r\n  longtap: ['longtap'],\r\n  input: ['input'],\r\n  blur: ['change', 'blur'],\r\n  submit: ['submit'],\r\n  focus: ['focus'],\r\n  scrolltoupper: ['scrolltoupper'],\r\n  scrolltolower: ['scrolltolower'],\r\n  scroll: ['scroll']\r\n}\r\n复制代码使用了 handleProxyWithVue 方法来代理小程序事件到vue事件。另外看下作者自己对这部分的思路事件代理机制：用户交互触发的数据更新通过事件代理机制完成。在 Vue.js 代码中，事件响应函数对应到组件的 method， Vue.js 自动维护了上下文环境。然而在小程序中并没有类似的机制，又因为 Vue.js 执行环境中维护着一份实时的虚拟 DOM，这与小程序的视图层完全对应，我们思考，在小程序组件节点上触发事件后，只要找到虚拟 DOM 上对应的节点，触发对应的事件不就完成了么；另一方面，Vue.js 事件响应如果触发了数据更新，其生命周期函数更新将自动触发，在此函数上同步更新小程序数据，数据同步也就实现了。getHandle 这个方法应该就是作者思路当中所说的：找到对应节点，然后找到handle。lifecycle.js在 initMP 方法中，自己创建小程序的App、Page。实现生命周期相关方法，使用 callHook代理兼容小程序App、Page的生命周期。官方文档生命周期中说到了：同 vue，不同的是我们会在小程序 onReady 后，再去触发 vue mounted 生命周期这部分查看， onReady 之后才会执行 next ，这个 next 回调最终是vue的 mountComponent。可以在 index.js 中看到。这部分代码也就是解决了\"小程序生命周期中触发vue生命周期\"。export function initMP (mpType, next) {\r\n  // ...\r\n    global.Page({\r\n      // 生命周期函数--监听页面初次渲染完成\r\n      onReady () {\r\n        mp.status = 'ready'\r\n\r\n        callHook(rootVueVM, 'onReady')\r\n        next()\r\n      },\r\n    })\r\n  // ...\r\n}\r\n复制代码在小程序onShow时，使用$nextTick去第一次渲染数据，参考上面提到的render.js。export function initMP (mpType, next) {\r\n  // ...\r\n  global.Page({\r\n    // 生命周期函数--监听页面显示\r\n    onShow () {\r\n      mp.page = this\r\n      mp.status = 'show'\r\n      callHook(rootVueVM, 'onShow')\r\n\r\n      // 只有页面需要 setData\r\n      rootVueVM.$nextTick(() => {\r\n        rootVueVM._initDataToMP()\r\n      })\r\n    },\r\n  })\r\n  // ...\r\n}\r\n复制代码在mpvue-loader生成template时，比如点击事件 @click 会变成 bindtap=\"handleProxy\" ，事件绑定全都会使用 handleProxy 这个方法。可以查看上面回顾一下。最终handleProxy调用的是event.js中的 handleProxyWithVue 。export function initMP (mpType, next) {\r\n  // ...\r\n    global.Page({\r\n      handleProxy (e) {\r\n        return rootVueVM.$handleProxyWithVue(e)\r\n      },\r\n    })\r\n  // ...\r\n}\r\n复制代码index.js最后index.js就负责各种初始化和mount。Class和Style为什么暂不支持组件原因：目前的组件是使用小程序的 template 标签实现的，给组件指定的class和style是挂载在template标签上，而template 标签不支持 class 及 style 属性。解决方案： 在自定义组件上绑定class或style到一个props属性上。// 组件ComponentA.vue\r\n <template>\r\n  <div class=\"container\" :class=\"pClass\">\r\n    ...\r\n  </div>\r\n</template>\r\n复制代码<script>\r\n    export default {\r\n    props: {\r\n      pClass: {\r\n        type: String,\r\n        default: ''\r\n      }\r\n    }\r\n  }\r\n</script>\r\n复制代码<!--PageB.vue-->\r\n<template>\r\n    <component-a :pClass=\"cusComponentAClass\"  />\r\n</template>\r\n复制代码<script>\r\ndata () {\r\n    return {\r\n      cusComponentAClass: 'a-class b-class'\r\n    }\r\n  }\r\n</script>\r\n复制代码<style lang=\"stylus\" scoped>\r\n  .a-class\r\n    border red solid 2rpx\r\n  .b-class\r\n    margin-right 20rpx\r\n</style>\r\n复制代码但是这样会有问题就是style加上scoped之后，编译模板生成的代码是下面这样的：.a-class.data-v-8f1d914e {\r\n   border: #f00 solid 2rpx;\r\n }\r\n .b-class.data-v-8f1d914e {\r\n   margin-right 20rpx\r\n }\r\n复制代码所以想要这些组件的class生效就不能使用scoped的style，改成下面这样，最好自己给a-class和b-class加前缀以防其他的文件引用这些样式：<style lang=\"stylus\">\r\n  .a-class\r\n    border red solid 2rpx\r\n  .b-class\r\n    margin-right 20rpx\r\n</style>\r\n\r\n<style lang=\"stylus\" scoped>\r\n  .other-class\r\n    border red solid 2rpx\r\n    \r\n   ...\r\n</style>\r\n复制代码在定义组件上绑定style属性到一个props属性上：<!--P组件ComponentA.vue-->\r\n <template>\r\n  <div class=\"container\" :style=\"pStyle\">\r\n    ...\r\n  </div>\r\n</template>\r\n复制代码<script>\r\n  export default {\r\n    props: {\r\n      pStyle: {\r\n        type: String,\r\n        default: ''\r\n      }\r\n    }\r\n  }\r\n</script>\r\n复制代码<!--PageB.vue-->\r\n<template>\r\n    <component-a :pStyle=\"cusComponentAStyle\"  />\r\n</template>\r\n复制代码<script>\r\nconst cusComponentAStyle = 'border:red solid 2rpx; margin-right:20rpx;'\r\ndata () {\r\n    return {\r\n      cusComponentAStyle\r\n    }\r\n  }\r\n</script>\r\n复制代码<style lang=\"stylus\" scoped>\r\n  ...\r\n</style>\r\n复制代码也可以通过定义styleObject，然后通过工具函数转化为styleString，如下所示：const bstyle = {\r\n  border: 'red solid 2rpx',\r\n  'margin-right': '20rpx'\r\n}\r\nlet arr = []\r\nfor (let [key, value] of Object.entries(bstyle)) {\r\n  arr.push(`${key}: ${value}`)\r\n}\r\n\r\nconst cusComponentAStyle = arr.join('; ')\r\n复制代码当然自定义组件确定只会改变某个css样式，通过pros传入单个样式的值，然后通过:style绑定肯定没问题：<!--组件ComponentA.vue-->\r\n <template>\r\n  <div class=\"container\" :style=\"{'background-color': backgroundColor}\">\r\n    ...\r\n  </div>\r\n</template>\r\n复制代码<script>\r\n    export default {\r\n    props: {\r\n      backgroundColor: {\r\n        type: String,\r\n        default: 'yellow'\r\n      }\r\n    }\r\n  }\r\n</script>\r\n复制代码<!-- PageB.vue -->\r\n<template>\r\n    <component-a backgroundColor=\"red\"  />\r\n</template>\r\n复制代码分包加载package.json修改升级： \"mpvue-loader\": \"^1.1.2-rc.4\" \"webpack-mpvue-asset-plugin\": \"^0.1.1\"新增： \"relative\": \"^3.0.2\"注意事项1.1.2-rc.5 修复 slot 文件路径生成错误的问题1.1.x 版本还不是很稳定，对稳定性要求较高的项目建议暂时使用 1.0.x 版本移动src/main.js中config相关内容到同级目录下main.json(新建)中export default {\r\n  // config: {...} 需要移动\r\n}\r\n\r\n复制代码to{\r\n \"pages\": [\r\n   \"pages/index/main\",\r\n   \"pages/logs/main\"\r\n  ],\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"pages/packageA\",\r\n     \"pages\": [\r\n       \"counter/main\"\r\n     ]\r\n   }\r\n ],\r\n \"window\": {...}\r\n}\r\n复制代码webpack 配置配合升级指南本次升级意在调整生成文件目录结构，对依赖的文件由原来的写死绝对路径该改为相对路径mpvue-loader@1.1.2-rc.4 依赖 webpack-mpvue-asset-plugin@0.1.0 做依赖资源引用之前写在 main.js 中的 config 信息，需要在 main.js 同级目录下新建 main.json 文件，使用 webapck-copy-plugin copy 到 build 目录下app.json 中引用的图片不会自动 copy 到 dist 目录下 json 配置文件是由 webapck-copy-plugin copy 过去的，不会处理依赖，可以将图片放到根目录下 static 目录下，使用 webapck-copy-plugin copy 过去build/webpack.base.conf.js+var CopyWebpackPlugin = require('copy-webpack-plugin')\r\n+var relative = require('relative')\r\n\r\n function resolve (dir) {\r\n   return path.join(__dirname, '..', dir)\r\n }\r\n\r\n-function getEntry (rootSrc, pattern) {\r\n-  var files = glob.sync(path.resolve(rootSrc, pattern))\r\n-  return files.reduce((res, file) => {\r\n-    var info = path.parse(file)\r\n-    var key = info.dir.slice(rootSrc.length + 1) + '/' + info.name\r\n-    res[key] = path.resolve(file)\r\n-    return res\r\n-  }, {})\r\n+function getEntry (rootSrc) {\r\n+  var map = {};\r\n+  glob.sync(rootSrc + '/pages/**/main.js')\r\n+  .forEach(file => {\r\n+    var key = relative(rootSrc, file).replace('.js', '');\r\n+    map[key] = file;\r\n+  })\r\n+   return map;\r\n }\r\n\r\n   plugins: [\r\n-    new MpvuePlugin()\r\n+    new MpvuePlugin(),\r\n+    new CopyWebpackPlugin([{\r\n+      from: '**/*.json',\r\n+      to: 'app.json'\r\n+    }], {\r\n+      context: 'src/'\r\n+    }),\r\n+    new CopyWebpackPlugin([ // 处理 main.json 里面引用的图片，不要放代码中引用的图片\r\n+      {\r\n+        from: path.resolve(__dirname, '../static'),\r\n+        to: path.resolve(__dirname, '../dist/static'),\r\n+        ignore: ['.*']\r\n+      }\r\n+    ])\r\n   ]\r\n }\r\n复制代码build/webpack.dev.conf.jsmodule.exports = merge(baseWebpackConfig, {\r\n   devtool: '#source-map',\r\n   output: {\r\n     path: config.build.assetsRoot,\r\n-    filename: utils.assetsPath('js/[name].js'),\r\n-    chunkFilename: utils.assetsPath('js/[id].js')\r\n+    filename: utils.assetsPath('[name].js'),\r\n+    chunkFilename: utils.assetsPath('[id].js')\r\n   },\r\n   plugins: [\r\n     new webpack.DefinePlugin({\r\n    module.exports = merge(baseWebpackConfig, {\r\n     // copy from ./webpack.prod.conf.js\r\n     // extract css into its own file\r\n     new ExtractTextPlugin({\r\n-      filename: utils.assetsPath('css/[name].wxss')\r\n+      filename: utils.assetsPath('[name].wxss')\r\n     }),\r\n    module.exports = merge(baseWebpackConfig, {\r\n       }\r\n     }),\r\n     new webpack.optimize.CommonsChunkPlugin({\r\n-      name: 'vendor',\r\n+      name: 'common/vendor',\r\n       minChunks: function (module, count) {\r\n         // any required modules inside node_modules are extracted to vendor\r\n         return (\r\n        module.exports = merge(baseWebpackConfig, {\r\n       }\r\n     }),\r\n     new webpack.optimize.CommonsChunkPlugin({\r\n-      name: 'manifest',\r\n-      chunks: ['vendor']\r\n+      name: 'common/manifest',\r\n+      chunks: ['common/vendor']\r\n     }),\r\n-    // copy custom static assets\r\n-    new CopyWebpackPlugin([\r\n-      {\r\n-        from: path.resolve(__dirname, '../static'),\r\n-        to: config.build.assetsSubDirectory,\r\n-        ignore: ['.*']\r\n-      }\r\n-    ]),\r\n\r\n复制代码build/webpack.prod.conf.jsvar webpackConfig = merge(baseWebpackConfig, {\r\n   devtool: config.build.productionSourceMap ? '#source-map' : false,\r\n   output: {\r\n     path: config.build.assetsRoot,\r\n-    filename: utils.assetsPath('js/[name].js'),\r\n-    chunkFilename: utils.assetsPath('js/[id].js')\r\n+    filename: utils.assetsPath('[name].js'),\r\n+    chunkFilename: utils.assetsPath('[id].js')\r\n   },\r\n   plugins: [\r\n    var webpackConfig = merge(baseWebpackConfig, {\r\n     }),\r\n     // extract css into its own file\r\n     new ExtractTextPlugin({\r\n-      // filename: utils.assetsPath('css/[name].[contenthash].css')\r\n-      filename: utils.assetsPath('css/[name].wxss')\r\n+      // filename: utils.assetsPath('[name].[contenthash].css')\r\n+      filename: utils.assetsPath('[name].wxss')\r\n     }),\r\n     // Compress extracted CSS. We are using this plugin so that possible\r\n     // duplicated CSS from different components can be deduped.\r\n    var webpackConfig = merge(baseWebpackConfig, {\r\n     new webpack.HashedModuleIdsPlugin(),\r\n     // split vendor js into its own file\r\n     new webpack.optimize.CommonsChunkPlugin({\r\n-      name: 'vendor',\r\n+      name: 'common/vendor',\r\n       minChunks: function (module, count) {\r\n         // any required modules inside node_modules are extracted to vendor\r\n         return (\r\n     var webpackConfig = merge(baseWebpackConfig, {\r\n     // extract webpack runtime and module manifest to its own file in order to\r\n     // prevent vendor hash from being updated whenever app bundle is updated\r\n     new webpack.optimize.CommonsChunkPlugin({\r\n-      name: 'manifest',\r\n-      chunks: ['vendor']\r\n-    }),\r\n+      name: 'common/manifest',\r\n+      chunks: ['common/vendor']\r\n+    })\r\n-    // copy custom static assets\r\n-    new CopyWebpackPlugin([\r\n-      {\r\n-        from: path.resolve(__dirname, '../static'),\r\n-        to: config.build.assetsSubDirectory,\r\n-        ignore: ['.*']\r\n-      }\r\n-    ])\r\n   ]\r\n })\r\n复制代码config/index.jsmodule.exports = {\r\n     env: require('./prod.env'),\r\n     index: path.resolve(__dirname, '../dist/index.html'),\r\n     assetsRoot: path.resolve(__dirname, '../dist'),\r\n-    assetsSubDirectory: 'static', // 不将资源聚合放在 static 目录下\r\n+    assetsSubDirectory: '',\r\n     assetsPublicPath: '/',\r\n     productionSourceMap: false,\r\n     // Gzip off by default as many popular static hosts such as\r\n@@ -26,7 +26,7 @@ module.exports = {\r\n     port: 8080,\r\n     // 在小程序开发者工具中不需要自动打开浏览器\r\n     autoOpenBrowser: false,\r\n-    assetsSubDirectory: 'static', // 不将资源聚合放在 static 目录下\r\n+    assetsSubDirectory: '',\r\n     assetsPublicPath: '/',\r\n     proxyTable: {},\r\n     // CSS Sourcemaps off by default because relative paths are \"buggy\"\r\n\r\n复制代码"}
{"title": "微信小程序JS导出和导入 ", "author": "Rolan", "pub_time": "2018-9-6 00:27", "article_content": "1. 导出1.1 方法和变量导出（写在被导出方法和变量的js文件）module.exports = {  variable: value,  method : methodName}1.2 class导出(es6语法)class HomeModule {  constructor(url) {    this.url = url;  }}export { HomeModule }2. 导入2.1 方法和变量的引入(写在需要引入其他js的方法或变量的JS文件中)var util = require(\"../../../utils/util.js\");  //注意这里引入的js文件路径写相对路径(绝对路径可能引入失败)var http = require(\"../../../utils/http.js\");    使用： util.method() 或 util.variable2.2 class的引入import { HomeModule } from \"../../../module/HomeModule.js\";//引入的js文件最好写相对路径  使用：      var homeModule = new HomeModule(listUrl);  //创建class对像后就可以直接调用对象的函数了。"}
{"title": "微信小程序语音聊天智能对话（demo） ", "author": "Rolan", "pub_time": "2018-9-6 00:36", "article_content": "项目中用到了 olami sdk把录音或者文字转化为用户可以理解的json字符串。效果图重要jS代码： //手指按下时 语音转文字  voiceToChar:function(){    var urls = app.globalData.slikToCharUrl;    var voiceFilePath = that.data.filePath;    if(voiceFilePath == null){      console.log(\"[Console log]:File path do not exist!\");      wx.showModal({        title: '录音文件不存在',        content: '我也不知道哪错了，反正你就再试一次吧！',        showCancel: false,        confirmText: '确定',        confirmColor: '#09BB07',      })      return;    }    var appkey = app.globalData.NLPAppkey;    var appsecret = app.globalData.NLPAppSecret;    var NLPCusid = app.globalData.NLPCusid;    wx.showLoading({      title: '语音识别中...',    })    wx.uploadFile({      url: urls,      filePath: voiceFilePath,      name: 'file',      formData: { \"appKey\": appkey, \"appSecret\": appsecret, \"userId\": NLPCusid },      header: { 'content-type': 'multipart/form-data' },      success: function (res) {        wx.hideLoading();        var data = JSON.parse(res.data);        var seg = JSON.parse(data.result).seg;        console.log(\"[Console log]:Voice to char:\" + seg);        if(seg == null || seg.length == 0){          wx.showModal({            title: '录音识别失败',            content: \"我什么都没听到，你再说一遍！\",            showCancel: false,            success: function (res) {            }          });          return;        }        that.addChat(seg, 'r');        console.log(\"[Console log]:Add user voice input to chat list\");        that.sendRequest(seg);        return;      },      fail: function (res) {        console.log(\"[Console log]:Voice upload failed:\" + res.errMsg);        wx.hideLoading();        wx.showModal({          title: '录音识别失败',          content: \"请你离WIFI近一点再试一次！\",          showCancel: false,          success: function (res) {          }        });      }    });  },olami 技术的识别语音代码：// 发送语料到语义平台  sendChat: function (e) {    let word = e.detail.value.ask_word ? e.detail.value.ask_word : e.detail.value;    console.log(\"[Console log]:User input:\" + word);    that.addChat(word, 'r');    console.log(\"[Console log]:Add user input to chat list\");    that.setData({      askWord: '',      sendButtDisable: true,    });    that.sendRequest(word);  },  // 发送请求到语义平台  sendRequest(corpus){    app.NLIRequest(corpus, {      'success': function (res) {        if (res.status == \"error\") {          wx.showToast({            title: '返回数据有误！',          })          return;        }        var resjson = JSON.parse(res);        var data = JSON.stringify(resjson.data);        that.NLIProcess(data);      },      'fail': function (res) {        wx.showToast({          title: '请求失败！',        })        return;      }    });   },  // 处理语义  NLIProcess: function(res){    var nlires = JSON.parse(res);    var nliArray = nlires.nli;    if(nliArray == null || nliArray.length == 0){      wx.showToast({        title: '返回数据有误！',      })      return;    }    var answer = nliArray[0].desc_obj.result;    if(answer == null){      wx.showToast({        title: '返回数据有误！',      })      return;    }    console.log(\"[Console log]:Add answer to chat list...\");    that.addChat(answer, 'l');    var dataArray = nliArray[0].data_obj;    if(dataArray != null && dataArray.length > 0){      var objType = nliArray[0].type;      if(objType == 'selection' && dataArray.length > 1){        that.newsProcess(dataArray);        return;      }      if (objType == 'news' && dataArray.length == 1) {        console.log(\"[Console log]:Add news to chat list...\");        var title = dataArray[0].title;        var detail = dataArray[0].detail;        var news = title + \"\\n\" + detail;         that.addChat(news, 'l');        return;      }      var content = dataArray[0].content;      if (content != null && content != answer){        console.log(\"[Console log]:Add content to chat list...\");        that.addChat(content, 'l');      }    }    return;  },源码： 百度云：https://pan.baidu.com/s/1jHJj1HG小程序社区博主：honey缘木鱼"}
{"title": "小程序-记牌器 ", "author": "Rolan", "pub_time": "2018-9-7 00:06", "article_content": "这个想法来自看直播时看主播斗地主时经常由于没有记牌器，判断失误导致输豆，所以做了这个记牌器。估计不会有人用 :laughing:，就当作练手，熟悉小程序的整个开发流程哈哈。 没想到提交第二天就审核通过了截图思路比较简单只有一个页面1.可选一副牌或两副牌2.点击相应牌减少对应牌的数量, 数量为0时该图标变灰3.可撤销，撤销操作仅保留最近100个点击操作4.重置操作会清空所有操作记录开发上选择的是 mpvuempvue.com/然后直接使用grid布局对卡牌进行排列<div class=\"gird-container\">\r\n  <div class=\"gird-item\" v-for=\"(poker, index) in pokers\" :key=\"index\">\r\n    <card :poker=\"poker\" :index=\"index\" @handleHuase=\"handleHuase\" @handleWang=\"handleWang\">\r\n    </card>\r\n  </div>\r\n</div>\r\n复制代码操作方法// 点击操作\r\nhandleHuase (obj) {\r\n// 这里用来记录操作历史\r\nthis.updateHistory.push(JSON.parse(JSON.stringify(this.pokers)))\r\n  if (this.pokers[obj.index][obj.huase] > 0) {\r\n    this.pokers[obj.index][obj.huase] -= 1\r\n    this.pokers[obj.index].count -= 1\r\n  } else {\r\n    this.pokers[obj.index][obj.huase] = this.defaultCount\r\n    this.pokers[obj.index].count += 1\r\n  }\r\n}\r\n复制代码// 撤销操作\r\nrollback () {\r\n  let pokers = this.updateHistory[this.updateHistory.length - 1]\r\n  this.pokers = pokers\r\n  this.updateHistory.pop(this.updateHistory.length - 1)\r\n}\r\n复制代码git地址github.com/jinggoing/m…"}
{"title": "mpvue小程序以及微信直播踩坑总结 ", "author": "Rolan", "pub_time": "2018-9-7 00:21", "article_content": "前段时间刚写完一个mpvue的小程序，现在得闲必须赶紧记录和总结一下，不然很多东西又要忘了我是比较熟悉vue的语法，但是也犹豫过是用原生还是用mpvue，因为那时候原生小程序已经相当成熟而mpvue才刚出来（踩坑和填坑的前人还很少）所以我学习了几天原生的框架和语法，果断选择了mpvue，真的是没有对比就没有伤害，对比原生体验不要太好mpvue是一个使用 Vue.js 开发小程序的前端框架，他是将我们写的vue文件重新编译成wxml等文件，最后的底层实现还是用的小程序语法，所以原生小程序语法也是比较重要的，而且像很多下拉刷新，到底部请求下一页什么的等等很多地方也是要用到小程序api的，所以建议大家在入坑之前还是了解一些小程序语法比较好附上官方文档mpvue.com/#_1项目配置使用官方的5分钟上手，生成一个基本框架，后来开发也没有手动修改过他的配置用到了4个插件mpvue-weui    ui库，相当方便轻量好使官网地址： kuangpf.com/mpvue-weui/…mpvue-toast  一个基于mpvue的简单弹窗组件因为mpvue目前还不支持全局的组件，所以没有办法像vue组件引入一次就能在所有页面使用，但是mpvue团队已经在考虑新增全局组件功能了github地址： github.com/linrui1994/…sass  不多介绍全局安装：npm install sass-loader node-sass --save-dev在style节点加上lang=”scss”，这样就可以愉快地使用sass进行开发了mpvue-router-patch   在mpvue 中使用 vue-router 兼容的路由写法当知道mpvue不支持vue-router的时候我还是非常难受，还好mpvue团队后面发布了这个插件，非常简单好用github地址： github.com/F-loat/mpvu…接下来的3个插件我没有用过但是和mpvue-router-patch一样是mpvue团队发布的，感觉应该也不差，也推荐给大家如果需要可以花时间了解一下mpvue-echarts    适用于 Mpvue 的 ECharts 组件github地址： github.com/F-loat/mpvu…微信小程序富文本解析组件  适用于 Mpvue 的微信小程序富文本解析自定义组件github地址： github.com/F-loat/mpvu…mpvue-entry自动生成各页面的入口文件  集中式页面配置，自动生成各页面的入口文件，优化目录结构，支持新增页面热更新github地址： github.com/F-loat/mpvu…ajax请求封装拿走不谢let urlPath = '' // 项目的域名\r\nexport function post(url, data) {\r\n  wx.showLoading({\r\n    title: '努力加载中',\r\n  })\r\n// 由于微信不会保存后端用于登陆验证的cookie，这里需要自己从登陆返回的数据里取到cookie，然后本地缓存，请求时在header里带上cookie\r\n  let header = {} \r\n  url === 'user/loginworker' // 通过传进来的url判断是否是登陆页\r\n    ? header = {} \r\n    : header = {\r\n      'content-type': 'application/x-www-form-urlencoded',\r\n      'cookie': wx.getStorageSync(\"sessionid\")\r\n    } \r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: urlPath + url,\r\n      data: data,\r\n      method: 'get',\r\n      header: header, success(res) {\r\n        console.log(res)\r\n        if (res.statusCode === 200) {\r\n          if (res.data === 9999) { // 与后端的后端返回9999表示cookie失效\r\n            wx.showModal({\r\n              content: '登陆超时请重新登陆',\r\n              showCancel: false,\r\n              success: function (res) {\r\n                if (res.confirm) {\r\n                  wx.navigateTo({\r\n                    url: '../../pages/login/main',\r\n                  })\r\n                }\r\n              }\r\n            })\r\n          } else if (res.data.code && res.data.code !== 200) { // 若返回coode码且不等于200表示传入参数有问题\r\n            res.message = res.data.message, reject(res)\r\n          } else resolve(res)\r\n            // 存储cookie\r\n          res.data.message === '登录成功。' ? wx.setStorageSync(\"sessionid\", res.header[\"Set-Cookie\"]) : \"\"\r\n        }else {\r\n          res.message = '服务器错误请求失败'\r\n          reject(res)\r\n        }\r\n        wx.hideLoading()\r\n      }, fail(err) {\r\n        err.message = '请求超时请稍后再试'\r\n        reject (err)\r\n        wx.hideLoading()\r\n      }\r\n    })\r\n  })\r\n}\r\n复制代码生命周期钩子created是vue的生命周期在mpvue里所有页面的created函数会在项目加载的时候被一起调用，可用性不大，可以使用onShow()代替，但是onShow()只有在隐藏又显示后才会显示,也就是第一次加载不会执行created() {\r\n    console.log('created')\r\n  },\r\n  mounted() {\r\n    console.log('mounted')\r\n  },\r\n  onLoad() {\r\n    console.log('onLoad')\r\n  },\r\n  onShow() {\r\n    console.log('onShow')\r\n  },\r\n  onUnload() {\r\n    console.log('onUnload')\r\n  },\r\n  onHide() {\r\n    console.log('onHide')\r\n  },\r\n复制代码页面跳转后并没有销毁页面实例比如一个搜索页面，页面第一次进来所有的数据都是空的，但你搜索一次之后，input框就有值了，这个时候再跳转到其他页面或者返回之后再进入这个页面那个值依然存在，页面跳转后并没有销毁页面实例，而是将其推入页面栈中，所以会保存之前的旧的数据，目前为止看到的比较统一的解决办法就是：在onShow()或者onLoad()手动清空关于微信直播这个小程序需要引入监控相当于是直播功能，这个组件也是有点坑Live-player组件本身只能播放，如果想要在组件上加功能，像什么全屏静音播放暂停之类的功能需要使用wx.createLivePlayerContext()方法，而且由于live-player层级是最高的，如果你需要在组件上加功能比如点一下全屏再点下退出全屏或者加css样式，你必须写在 cover-view cover-image上面，直接加在live-player上是没用的<live-player id='liveInfo' src=\"\" mode=\"live\" autoplay='false' @bindstatechange=\"statechange\" binderror=\"error\">\r\n    <cover-image @click=\"requestFullScreen\"></cover-image>\r\n</live-player>\r\n复制代码你以为这样就完了嘛，不，如果你有一个直播列表，比如一个屏幕同时有一个以上的live-player组件那么你全屏的时候就会发现其余的组件因为层级的原因全部覆盖在你全屏的那个组件之上解决办法：全屏是v-if隐藏其余的组件，退出时再显示如有不足、需要改善或者还能优化的地方欢迎指出不胜感激，欢迎留言交流  (´▽`ʃ♡ƪ)**"}
{"title": "小程序绘图工具painter-json文件绘制保存分享图-可点击任意元素触发函数 ... ... ", "author": "Rolan", "pub_time": "2018-8-27 00:25", "article_content": "Painter是由酷家乐移动前端团队打造的一款小程序绘图组件。\r\n原项目地址：github.com/Kujiale-Mob…\r\n新版地址：github.com/shesw/Paint…\r\n这款交互版原来是为了针对业务中的新需求而由我自己开发的，后来需求改动，所以并没有用上。组里大佬考虑种种原因（主要是项目没用上，=0=～～），让我先在自己的github上开源。这版painter与原版的区别在于：\r\n\r\n添加了交互事件。Painter本质是以canvas为基础的，小程序的canvas有许多限制。允许canvas上元素的交互点击事件，可以实现更为便捷的功能，比如原来需要在canvas上添加功能按钮，现在可以直接画在canvas上\r\n添加拖拽元素的功能。目前这个功能没有完善好，因为它的滑动动作会与小程序的全屏滑动事件冲突，因此，拖拽功能在固定的页面上效果才好，如在拖拽时设置overflow: hidden等。\r\n\r\n这里将新版的Painter称为dancing-painter。引入方式请参考readme和demo。\r\n演示：\r\n\r\n主要功能：\r\n指原版的painter的功能。这些功能依然是本项目的主(实)要(用)功能。\r\n简介：\r\n原版的使用简介请参见 juejin.im/post/5b40b1…\r\n简单来讲，使用过程如下图所示，可以结合demo来看：\r\n距离首次开源Painter库已经有一段时间了，这期间获益于各路道友的帮助和提点，Painter进行了几波更新（原项目地址)：\r\n新增特性：\r\n\r\n增加align属性，可以使任意元素可以实现左中右对齐。\r\n加入文字换行的能力。对一段文字设置width或者maxLines，都有可能触发文字的换行。\r\n添加文字的一些属性：fontWeight, textDecoration, textStyel(fill, stroke), maxLines, lineHeight\r\n图片mode属性，实现图片裁剪、缩放，默认为aspectFill\r\n图片不设置width, heighti属性，使用默认宽高\r\nleft, right, top, bottom对负数的支持\r\n\r\n修复问题：\r\n\r\n某些机型上切边会出现黑线。\r\n安卓机型上圆角无法显示\r\n使用文件前检查文件是否正常\r\n二维码大小显示异常\r\n\r\n交互功能：\r\n这一版的特色主要是具备元素的点击事件实现以及拖拽功能，做出来以后因为项目上暂时用不上，所以感觉功能上可能比较鸡肋。不过还蛮好玩的"}
{"title": "微信支付服务商接入指引 ", "author": "Rolan", "pub_time": "2018-8-27 00:33", "article_content": "微信支付服务商接入指引本文主要针对服务商下特约商户的小程序支付进行讲解。（扫码支付， h5支付大致流程都差不多，了解了小程序支付能够很快接入其他支付类型）说明：本文中的支付都是指在服务商模式下支付主体服务商:拥有支付开发能力的第三方提供商普通商户: 拥有开发能力的商户特约商户:服务商下的商户一个商家主体可以在不同服务商下申请特约商户，每个服务商都会给商家主体在此服务商下一个特约商户号。普通商户申请需要花费大约300RMB，服务商申请特约商户不需要费用。一个商家主体可以申请 普通商户，特约商户。同一个商户主体申请的普通商户与在服务商下申请的特约商户号是独立的。服务商服务商下的特约商户的资金流转不会直接经过服务商的支付账户，最终消费者的资金直接和服务商下的特约商户进行来往，但是服务商可以查看自己下的特约商户资金流水。服务商小程序开发文档开发支付开发之前申请注册服务商，通过之后登录微信商户平台,进入菜单: 服务商功能 --> 特约商户管理 -->新增商户（也就是申请服务商下的特约商户）申请如果没有问题会在三到五天通过，之后可以在特约商户管理下看到服务商自己的特约商户，我们在开发中需要 服务商商户号及这里的商户号（特约商户号）支付需要接口:微信统一下单，及提供给微信的回调接口微信官方给的业务流程图：可以很清晰的理解业务流程走向。统一下单接口微信统一下单请求参数统一下单请求参数封装为我们可以处理的对象：此处我的命名是： WechatUnifiedorderRequest以下是我开发中遇到一些坑，主要是由于微信官方的文档给的参数很模糊，特别是小程序支付。在填充好了WechatUnifiedorderRequest对象后对我们填充的值按照字典排序，连接key进行签名，以xml格式字符向微信发起请求我们需要对对象按照字典序排序第一步，设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串stringA。字典排序后的字符连接key（需要在微信商户平台进行配置建议使用UUID生成32位）MD5加密签名，得到sign填充WechatUnifiedorderRequest对象WechatUnifiedorderRequest转换为微信需要的xml类型发起请求得到微信统一下单的响应（是xml字符格式),解析为对象（对返回的响应封装对象进行处理WechatUnifiedorderResponse），对返回的对象进行验证，通过验证返回给小程序 需要的参数及签名 小程序调起支付API小程序支付成功，微信开始回调在统一下单传给微信的回调地址获取下单用户的真实IP /**\r\n     * 获取用户真实IP\r\n     * 如果有代理，获取真实客户端IP\r\n     * @param request\r\n     * @return\r\n     */\r\n    public  static  String getRealId(HttpServletRequest request){\r\n\r\n        String xForwardedForHeader= request.getHeader(\"X-Forwarded-For\");\r\n        if(xForwardedForHeader == null){\r\n            return  request.getRemoteAddr();\r\n\r\n        }else {\r\n            return  new StringTokenizer(xForwardedForHeader, \",\").nextToken().trim();\r\n        }\r\n\r\n    }按照字典序排序 /**\r\n     * 使用java反射机制，动态获取对象的属性和参数值，排除值为null的情况，并按字典序排序\r\n     * @param object\r\n     * @return\r\n     */\r\n    public static   String getSortMap(Object object) throws  Exception{\r\n        //1.得到属性的名称及值 如果为null不存入map\r\n        Field [] fields = object.getClass().getDeclaredFields();\r\n        Map<String,String> map = new HashMap<>();\r\n        for(Field field : fields){\r\n            String name = field.getName();\r\n            /*String methodName = \"get\"+name.replaceFirst(name.substring(0, 1), name.substring(0, 1)\r\n                    .toUpperCase());*/\r\n            //通过get方法直接获取属性值\r\n            field.setAccessible(true);\r\n            Object value = field.get(object);\r\n            if (value != null){\r\n                map.put(name, value.toString());\r\n            }\r\n\r\n\r\n        }\r\n        //排序\r\n        Map<String, String> sortMap = new TreeMap<String,String>(\r\n                new Comparator<String>() {\r\n\r\n                    @Override\r\n                    public int compare(String arg0, String arg1) {\r\n\r\n                        return arg0.compareTo(arg1);\r\n                    }\r\n                });\r\n        sortMap.putAll(map);\r\n\r\n\r\n        StringBuilder sortFeil = new StringBuilder();\r\n        //得到键值对的格式（即key1=value1&key2=value2…\r\n        sortMap.forEach((k,v)-> {\r\n            sortFeil.append(k+\"=\"+v+\"&\");\r\n        });\r\n        //移除最后一个 &\r\n        sortFeil.deleteCharAt(sortFeil.length()-1);\r\n        return sortFeil.toString();\r\n\r\n    }\r\n使用字典序返回的字符连接key，使用MD5进行加密，得到signWechatUnifiedorderRequest转换为微信需要的xml类型在WechatUnifiedorderRequest对象上使用注解@xmlAccessorType @xmlAccessorType(XmlAccessType.FIELD)@xmlRootElement @xmlRootElement(name =\"xml\") ( name = \"xml : \"WechatUnifiedorderReques对象转换为xml的根名称)/**\r\n * 微信统一下单请求对象\r\n *\r\n * @Author xuelongjiang\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlRootElement(name = \"xml\")//xml的根元素\r\npublic class WechatUnifiedorderRequest  implements Serializable{\r\n}\r\n对象转换为xml字符引入包：import javax.xml.bind.JAXBContext /**\r\n     * 对象转换为xml\r\n     * @param object\r\n     * @return\r\n     */\r\n    public static  String objectToXml(Object object){\r\n\r\n        StringWriter sw = new StringWriter();\r\n        try {\r\n\r\n            JAXBContext context = JAXBContext.newInstance(object.getClass());\r\n            Marshaller marshaller =  context.createMarshaller();\r\n            marshaller.marshal(object,sw);\r\n\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n            logger.error(\"对象解析xml出现异常，对象为\"+object.toString());\r\n        }\r\n\r\n        return sw.toString();\r\n    }得到微信统一下单的响应（是xml字符格式),解析为对象封装对象：WechatUnifiedorderResponse 表示微信统一下单响应的对象。请求微信统一下单返回示例：<xml>\r\n   <return_code><![CDATA[SUCCESS]]></return_code>\r\n   <return_msg><![CDATA[OK]]></return_msg>\r\n   <appid><![CDATA[wx2421b1c4370ec43b]]></appid>\r\n   <sub_appid><![CDATA[wx2421b1c4370ec11b]]></sub_appid>\r\n   <mch_id><![CDATA[10000100]]></mch_id>\r\n   <sub_mch_id>![CDATA[10000101]]></appid>\r\n   <nonce_str><![CDATA[IITRi8Iabbblz1Jc]]></nonce_str>\r\n   <sign><![CDATA[7921E432F65EB8ED0CE9755F0E86D72F]]></sign>\r\n   <result_code><![CDATA[SUCCESS]]></result_code>\r\n   <prepay_id><![CDATA[wx201411101639507cbf6ffd8b0779950874]]></prepay_id>\r\n   <trade_type><![CDATA[JSAPI]]></trade_type>\r\n</xml>参数值用XML转义即可，CDATA标签用于说明数据不被XML解析器解析，在转为对象的时候我们需要解析<![CDATA[]]>WechatUnifiedorderResponse对象使用注解@XmlAccessorType(XmlAccessType.FIELD)@XmlRootElement(name = \"xml\")//解析xml的根元素以上的和WechatUnifiedorderRequest是一样，但是由于需要解析<![CDATA[]]>，我们创建CDataAdapter继承XmlAdapter ，使用注解@XmlJavaTypeAdapter来处理，在WechatUnifiedorderResponse需要处理<![CDATA[]]>的域上使用注解如下： @XmlJavaTypeAdapter(CDataAdapter.class)// 解析<![CDATA[]]>\r\n    private String return_code; //返回状态码CDataAdapter解析<![CDATA[]]>\r\n/**\r\n *\r\n * 注解使用， 对象与xml转换的字段需要有 <![CDATA[]]>\r\n *\r\n * @Author xuelongjiang\r\n */\r\npublic class CDataAdapter extends XmlAdapter<String,String> {\r\n\r\n    private static Logger logger = LoggerFactory.getLogger(CDataAdapter.class);\r\n\r\n    /**\r\n     * Do-nothing constructor for the derived classes.\r\n     */\r\n    protected CDataAdapter() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Convert a value type to a bound type.\r\n     *\r\n     * @param v The value to be converted. Can be null.\r\n     * @throws Exception if there's an error during the conversion. The caller is responsible for\r\n     *                   reporting the error to the user through {@link ValidationEventHandler}.\r\n     */\r\n    @Override\r\n    public String unmarshal(String v) throws Exception {\r\n\r\n      if(\"<![CDATA[]]>\".equals(v)){\r\n          return \"\";\r\n      }\r\n      String v1 = null;\r\n      String v2 = null;\r\n\r\n      String subStart = \"<![CDATA[\";\r\n      int a = v.indexOf(subStart);\r\n      if(a>= 0){\r\n          v1 = v.substring(subStart.length(),v.length());\r\n\r\n      }else {\r\n          return v;\r\n      }\r\n      String subEnd = \"]]>\";\r\n      int b = v1.indexOf(subEnd);\r\n      if(b>= 0){\r\n          v2 = v1.substring(0,b);\r\n      }\r\n      return v2;\r\n\r\n    }\r\n\r\n    /**\r\n     * Convert a bound type to a value type.\r\n     *\r\n     * @param v The value to be convereted. Can be null.\r\n     * @throws Exception if there's an error during the conversion. The caller is responsible for\r\n     *                   reporting the error to the user through {@link ValidationEventHandler}.\r\n     */\r\n    @Override\r\n    public String marshal(String v) throws Exception {\r\n\r\n        logger.info(\"对象转换xml:\"+\"<![CDATA[\"+ v +\"]]>\");\r\n        return \"<![CDATA[\"+ v +\"]]>\";\r\n    }\r\n}\r\n\r\n到此为止，我们已经得到微信统一下单的响应值了，后续的处理不是很复杂。按照文档不会有很大的坑。在做微信支付的时候，难点是以上的：请求参数说明模糊，在经历几次的传参试验及百度谷歌之后，才明白了参数的具体的使用，其实后续在做扫码支付的时候，发现扫码支付解释的比较清楚，小程序的文档确实比较坑。参考文档：https://developers.weixin.qq....https://segmentfault.com/a/11...https://developers.weixin.qq...."}
{"title": "轻松生成小程序分享海报 ", "author": "Rolan", "pub_time": "2018-8-29 00:15", "article_content": "作者：jasondu原文：https://segmentfault.com/a/1190000016121303小程序海报组件https://github.com/jasondu/wx...需求小程序分享到朋友圈只能使用小程序码海报来实现，生成小程序码的方式有两种，一种是使用后端方式，一种是使用小程序自带的canvas生成；后端的方式开发难度大，由于生成图片耗用内存比较大对服务端也是不小的压力；所以使用小程序的canvas是一个不错的选择，但由于canvas水比较深，坑比较多，还有不同海报需要重现写渲染流程，导致代码冗余难以维护，加上不同设备版本的情况不一样，因此小程序海报生成组件的需求十分迫切。在实际开发中，我发现海报中的元素无非一下几种，只要实现这几种，就可以通过一份配置文件生成各种各样的海报了。海报中的元素分类要解决的问题单位问题canvas隐藏问题圆角矩形、圆角图片多段文字超长文字和多行文字缩略问题矩形包含文字多个元素间的层级问题图片尺寸和渲染尺寸不一致问题canvas转图片IOS 6.6.7 clip问题关于获取canvas实例单位问题canvas绘制使用的是px单位，但不同设备的px是需要换算的，所以在组件中统一使用rpx单位，这里就涉及到单位怎么换算问题。通过wx.getSystemInfoSync获取设备屏幕尺寸，从而得到比例，进而做转换，代码如下：const sysInfo = wx.getSystemInfoSync();\r\nconst screenWidth = sysInfo.screenWidth;\r\nthis.factor = screenWidth / 750;    // 获取比例\r\nfunction toPx(rpx) {    // rpx转px\r\n    return rpx * this.factor;\r\n}\r\nfunction toRpx(px) {    // px转rpx\r\n    return px / this.factor;\r\n},canvas隐藏问题在绘制海报过程时，我们不想让用户看到canvas，所以我们必须把canvas隐藏起来，一开始想到的是使用display:none; 但这样在转化成图片时会空白，所以这个是行不通的，所以只能控制canvas的绝对定位，将其移出可视界面，代码如下：.canvas.pro {\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: -9999rpx;\r\n}圆角矩形、圆角图片由于canvas没有提供现成的圆角api，所以我们只能手工画啦，实际上圆角矩形就是由4条线（黄色）和4个圆弧（红色）组成的，如下：圆弧可以使用canvasContext.arcTo这个api实现，这个api的入参由两个控制点一个半径组成，对应上图的示例canvasContext.arcTo(x1, y1, x2, y2, r)接下来我们就可以非常轻松的写出生成圆角矩形的函数啦/**\r\n * 画圆角矩形\r\n */\r\n_drawRadiusRect(x, y, w, h, r) {\r\n    const br = r / 2;\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(this.toPx(x + br), this.toPx(y));            // 移动到左上角的点\r\n    this.ctx.lineTo(this.toPx(x + w - br), this.toPx(y));        // 画上边的线\r\n    this.ctx.arcTo(this.toPx(x + w), this.toPx(y), this.toPx(x + w), this.toPx(y + br), this.toPx(br));                                                    // 画右上角的弧        \r\n    this.ctx.lineTo(this.toPx(x + w), this.toPx(y + h - br));    // 画右边的线\r\n    this.ctx.arcTo(this.toPx(x + w), this.toPx(y + h), this.toPx(x + w - br), this.toPx(y + h), this.toPx(br));                                              // 画右下角的弧\r\n    this.ctx.lineTo(this.toPx(x + br), this.toPx(y + h));        // 画下边的线\r\n    this.ctx.arcTo(this.toPx(x), this.toPx(y + h), this.toPx(x), this.toPx(y + h - br), this.toPx(br));                                                    // 画左下角的弧\r\n    this.ctx.lineTo(this.toPx(x), this.toPx(y + br));            // 画左边的线\r\n    this.ctx.arcTo(this.toPx(x), this.toPx(y), this.toPx(x + br), this.toPx(y), this.toPx(br));                                                    // 画左上角的弧\r\n}如果是 画线框 就使用 this.ctx.stroke();如果是 画色块 就使用 this.ctx.fill();如果是 圆角图片 就使用this.ctx.clip();\r\nthis.ctx.drawImage(***);clip() 方法从原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）。多段文字如果是连续多段不同格式的文字，如果让用户每段文字都指定坐标是不现实的，因为上一段文字的长度是不固定的，这里的解决方案是使用 ctx.measureText （基础库 1.9.90 开始支持）Api来计算一段文字的宽度，记住这里返回宽度的单位是px（ 坑 ），从而知道下一段文字的坐标。超长文字和多行文字缩略问题设置文字的宽度，通过 ctx.measureText 知道文字的宽度，如果超出设定的宽度，超出部分使用“...”代替；对于多行文字，经测试发现字体的高度大约等于字体大小，并提供lineHeight参数让用户可以自定义行高，这样我们就可以知道下一行的y轴坐标了。矩形包含文字这个同样使用 ctx.measureText 接口，从而控制矩形的宽度，当然这里用户还可以设置paddingLeft和paddingRight字段；文字的垂直居中问题可以设置文字的基线对齐方式为middle（ this.ctx.setTextBaseline('middle'); ），设置文字的坐标为矩形的中线就可以了；水平居中 this.ctx.setTextAlign('center'); ;多个元素间的层级问题由于canvas没有Api可以设置绘制元素的层级，只能是根据后绘制层级高于前面绘制的方式，所以需要用户传入zIndex字段，利用数组排序（Array.prototype.sort）后再根据顺序绘制。图片尺寸和渲染尺寸不一致问题绘制图片我们使用 ctx.drawImage() API；如果使用 drawImage(dx, dy, dWidth, dHeight) ，图片会压缩尺寸以适应绘制的尺寸，图片会变形，如下图：在基础库1.9.0起支持 drawImage(sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)  ，sx和sy是源图像的矩形选择框左上角的坐标，sWidth和sHeight是源图像的矩形选择框的宽度和高度，如下图：如果绘制尺寸比源图尺寸宽，那么绘制尺寸的宽度就等于源图宽度；反之，绘制尺寸比源图尺寸高，那么绘制尺寸的高度等于源图高度；我们可以通过 wx.getImageInfo Api获取源图的尺寸；canvas转图片在canvas绘制完成后调用 wx.canvasToTempFilePath Api将canvas转为图片输出，这样需要注意， wx.canvasToTempFilePath 需要写在 this.ctx.draw 的回调中，并且在组件中使用这个接口需要在第二个入参传入this（ 坑 ），如下this.ctx.draw(false, () => {\r\n    wx.canvasToTempFilePath({\r\n        canvasId: 'canvasid',\r\n        success: (res) => {\r\n            wx.hideLoading();\r\n            this.triggerEvent('success', res.tempFilePath);\r\n        },\r\n        fail: (err) => {\r\n            wx.hideLoading();\r\n            this.triggerEvent('fail', err);\r\n        }\r\n    }, this);\r\n});IOS 6.6.7 clip问题在IOS 6.6.7版本中clip方法连续裁剪图片时,只有第一张有效，这是微信的bug，官方也证实了（ https://developers.weixin.qq.... ）关于获取canvas实例我们可以使用 wx.createCanvasContext 获取小程序实例，但在组件中使用切记第二个参数需要带上this，如下this.ctx = wx.createCanvasContext('canvasid', this);如何使用组件https://github.com/jasondu/wx..."}
